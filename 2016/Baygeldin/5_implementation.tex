\section{Реализация}
\subsection{Реализация алгоритма}
Алгоритм был реализован на языке F\# семейства .NET в библиотеке для работы с конечными преобразователями YC.FST \cite{polubelova}. Можно выделить следующие особенности реализации.
\begin{itemize}
\item Класс конечных преобразователей в этой библиотеке поддерживает только целые числа в качестве состояний, но не кортежи из целых чисел, как это представляется в псевдокоде алгоритма. Поэтому было принято решение отображать сжатые представления кортежей из целых чисел в целые числа.
\item Для проверки корректности работы алгоритма были написаны модульные тесты, в которых производится композиция и сравнение FST, составленных вручную.
\end{itemize} 


\subsection{Интеграция}
В процессе работы была произведена реорганизация проекта YaccConstructor, одной из целей которой являлось получение возможности сравнения производительности текущего и выбранного алгоритмов. В рамках интеграции были выполнены следующие задачи.

\begin{itemize}
\item Библиотека YC.FST была интегрирована в библиотеку для работы с графами QuickGraph \cite{quick_graph}.
\item Был произведен рефакторинг, заключавшийся в подмене сторонней библиотеки QuickGraph в YaccConstructor на использование собственной сборки этой библиотеки.
\item Библиотека для работы с позициями в тексте YC.Utils.SourceText \cite{source_text} была интегрирована в проект YaccConstructor с целью ее дальнейшего использования при оптимизации алгоритма лексического анализа.
\end{itemize} 

\section{Экспериментальное исследование}
Сравнение производительности было произведено на заранее построенных регулярных аппроксимациях, построенных по реальному коду, в котором запросы T-SQL (Transact-SQL) формируются динамически, и лексическом анализаторе T-SQL. Результаты измерений в таблице~\ref{table} показывают, что реализация выбранного алгоритма дает существенный прирост в производительности как на небольших синтетических примерах, так и на реальном коде, регулярные аппроксимации которого содержат большое количество ребер и вершин.

\begin{table}[h]
  \centering
    \begin{tabular}{ p{2.5cm} | p{2.3cm} | p{2.4cm} | p{2.4cm}  }
  Кол-во вершин в регулярной аппроксимации &
  Кол-во ребер в регулярной аппроксимации & 
  Время работы текущего алгоритма (мс) & 
  Время работы выбранного алгоритма (мс) \\ \hline
  2 & 1 & 74 & 4 \\ \hline
  8 & 34 & 133 & 7 \\ \hline
  40 & 140 & 676 & 39 \\ \hline
  215 & 895 & 4045 & 248 \\ \hline
  310 & 687 & 7184 & 394 \\ \hline
  250 & 738 & 16526 & 1133 \\ \hline
  711 & 1766 & 30285 & 2068 \\ 
  \end{tabular}
  \caption{Сравнение производительности алгоритмов композиции FST, построенных по регулярным аппроксимациям динамически формируемых выражений на языке T-SQL}
  \label{table}
\end{table}

На выборке из 600 примеров, математическое ожидание ускорения (в количестве раз) выбранного алгоритма по сравнению с текущим равно 18.7, а среднее квадратичное отклонение равно 3.23. Однако стоит заметить, что в специфике нашей задачи выбранный алгоритм должен давать константный выигрыш в производительности для определенного языка по сравнению с текущим вне зависимости от входных данных. Но задачей данной работы являлось сравнение именно реализаций алгоритмов, а они отличаются техническими оптимизациями и необходимостью производить удаление недостижимых вершин после работы текущего алгоритма, в результате чего выигрыш в производительности перестает быть константным.

