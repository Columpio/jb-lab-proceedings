\section{Реализация}
\label{sec:impl}
\lstset{basicstyle=\normalsize\ttfamily, columns=fullflexible}
В данном разделе описывается реализация генератора принтеров и изменения в архитектуре принтер-плагина, позволяющие интегрировать в него полученные генератором принтеры, а так же некоторые ограничения, накладываемые на полученный код.

\subsection{Изменение архитектуры принтер-плагина}
Изначально плагин создавался с целью форматирования только программ на языке Java, и не предполагалось никаких механизмов расширения числа поддерживаемых языков.
Метод добавления поддерживаемых языков \cite{paper:while} по сути предполагал создание аналогичного плагина, но для программ на другом языке.
То есть помимо принтера требовалось реализовывать интерфейс взаимодействия плагина с пользователем.
%Такой подход накладывал дополнительные расходы по созданию интерфейса взаимодействия с пользователем.
%Кроме того, один и тот же код приходилось переносить в каждую такую реализацию.
Структура кода была монолитной, и поэтому большую его часть приходилось переносить в каждый новый плагин.
Намного удобнее было бы свести все поддерживаемые языки в единую систему, чтобы пользователю не приходилось задумываться об установке отдельного плагина для каждого языка, а затем, при форматировании, выбирать соответствующий язык программирования.
Для этого требовалось изменить архитектуру системы путем выделения языконезависимой части в отдельный модуль.
При этом было необходимо минимизировать количество кода, который нужно будет генерировать (только принтер и компоненты).
На рис.~\ref{impl:architechture} представлена конечная архитектура принтер-плагина\footnote{\texttt{https://bitbucket.org/igorozernykh/printerplugin}}\footnote{\texttt{https://github.com/IgorOzernykh/printer-core}}.
Для добавления поддержки нового языка в принтер-плагин требуется генерировать только языкозависимую часть (с помощью Grammar-Kit).
\begin{figure}[h]
    \centering
    \includegraphics[width=.85\textwidth]{Ozernykh/images/architech.png}
    \caption{Архитектура принтер-плагина}
    \label{impl:architechture}
\end{figure}

\subsection{Генератор принтеров в плагине Grammar-Kit}
После определения значимых правил, поддеревьев и их свойств происходит генерация кода компонент принтера.
Генерация кода происходит с использованием текстовых файлов, которые имеют набор меток вида \lstinline{@TEXT@} для вставки соответствующей информации (рис.~\ref{impl:templateFile}).
Метки могут быть предназначены как для вставки названий классов, типов, так и для целых методов этих классов.
Для каждого метода также имеется свой шаблон с набором меток.
Таким образом, построение итогового кода осуществляется путём заполнения более мелких шаблонов нужной информацией и подстановкой их в более крупные.

Существует два основных шаблона: для обычных компонент и для списочных.
Необходимость такого разграничения появилась из-за различного набор методов и их реализации.
Упомянутый ранее модификатор \emph{list}, применяемый к правилам грамматики, явно задает шаблон для генерации компонент.
\begin{figure}[h]
    \centering
 	\lstinputlisting{Ozernykh/codes/templateFile.txt}
 	\caption{Шаблон для генерации компонент}
    \label{impl:templateFile}
\end{figure}
Аналогичным образом генерируется класс принтера.

\subsection{Генерация файловой компоненты}
Полученный в результате работы генератора принтер и его компоненты зависят от классов внутреннего представления программ.
Так как классы внутреннего представления и соответствующие компоненты принтера генерируются по правилам грамматики, то мы можем гарантировать их корректное взаимодействие.
Однако принтер вынужден также взаимодействовать и с классами, которые создаются вручную.
Одним из них является класс внутреннего представления, описывающий структуру файла данного языка.
%Способ создания такого класса не подчиняется строгим правилам и может иметь вариации
Разработчик плагина для поддержки нового языка может задать данный класс разными способами, поэтому возникают трудности при генерации компоненты стандартным способом (разное число поддеревьев, которое можно получить при генерации и которое указано в синтаксическом узле; несоответствие имен методов, их типов).
Решением этой проблемы стало явное задание поддеревьев, которые будут сгенерированы.
Например, поддеревья для структуры, описывающей файла языка Java, можно задать следующим образом:
{
\begin{lstlisting}
fileSubtrees=``PackageStatement, ImportList, Classes!*''.
\end{lstlisting}
}
\noindent
Названия поддеревьев соответствуют методам узла синтаксического дерева, ``*'' указывает, что возвращаемых тип~--- коллекция (массив или список), а ``!''~---  является ли поддерево обязательным (аналог аннотаций \lstinline{@NotNull} и \lstinline{@Nullable}). 

\subsection{Ограничения}
Для преобразования программного текста в объекты, которыми оперирует система, используется \emph{фабрика элементов}.
Она, как и класс, описывающий файл языка, создается вручную.
Причем заранее неизвестно, каким образом инстанциируются объекты данного класса, неизвестна сигнатура методов, поэтому, чтобы обеспечить взаимодействие принтера и фабрики элементов, необходимо вручную реализовать метод \emph{createElementFromText} в классе принтера.
