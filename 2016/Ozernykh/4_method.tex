\section{Метод генерации декларативных принтеров}
\lstset{basicstyle=\normalsize\ttfamily, columns=fullflexible}
В данном разделе описывается соответствие между XML-описаниями \cite{paper:while} и правилами грамматики, необходимые преобразования грамматики, а также процесс отбора правил, необходимых для получения принтера языка.

\subsection{Определение поддеревьев и их свойств для правил грамматики}
Текущий способ добавления новых языков в принтер-плагин предполагает создание описания всех значимых компонент языка.
На рис.~\ref{mth:whileComponent} представлено XML-описание структуры языка While.
\fvset{frame=lines,framesep=5pt}
\begin{figure}[b]
    \centering
    \lstinputlisting[language=XML]{Ozernykh/codes/whileComponent.txt}
\caption{XML-описание цикла с предусловием языка While}
\label{mth:whileComponent}
\end{figure}
%}
\noindent
Количество таких структур в языке может быть большим, а значит, процесс создания такого описания может быть весьма трудоемким.
Для каждой компоненты (\emph{component}) принтера в XML-описании необходимо указать ее имя (\emph{name}), класс внутреннего представления (\emph{psiComponentClass}), 
%метод фабрики элементов (класс, преобразующий текст в объекты, которыми оперирует система), 
    а так же список поддеревьев (\emph{subtree}) и их свойства.
Данные свойства приведены ниже.% (на примере второго поддерева). 
\begin{enumerate}
    \item Имя поддерева (\emph{name}).
    \item Метод класса внутреннего представления, возвращающий данное поддерево или коллекцию поддеревьев такого типа (\emph{psiGetMethod}).% (\lstinline{psiGetMethod="StmtList"}).
    \item Является ли поддерево обязательным для синтаксической корректности структуры (\emph{isRequired}).% (\lstinline{isRequred="true"}).
    \item Является ли поддерево набором однотипных элементов (\emph{hasSeveralElements}).% (\lstinline{hasSeveralElements="false"}).
\end{enumerate}
Третье свойство с точки зрения принтера указывает на необходимость построения текстового представления для данного поддерева.
Так, в языке Java блок \lstinline{else} оператора ветвления необязателен, соответственно, для него может не существовать представления в синтаксическом дереве, значит, текстовое представление дерева оператора ветвления не будет содержать этот блок. 
В свою очередь, блок \lstinline{then} является обязательным, и невозможность получения текстового представления для него приведет к невозможности получения текстового представления и для всего оператора ветвления.
Четвертое свойство указывает, что поддерево является набором однотипных узлов синтаксического дерева.
Например, тело функции состоит из нескольких операторов, и чтобы получить текстовое представление тела функции, необходимо получить текстовые представления для этих операторов и объединить их, расположив друг под другом.
В случае поддерева \lstinline{body} на рис.~\ref{mth:whileComponent} \lstinline{hasSeveralElements="false"}, так как синтаксического дерево имеет отдельный узел для представления набора операторов (\lstinline{stmt_list}), то есть \lstinline{body} состоит из одного \lstinline{stmt_list}.
%Четвертое свойство указывает, что поддерево является коллекцией элементов синтаксического дерева, и текстовое представление поддерева есть объединение представлений для каждого элемента коллекции. %%TODO: про hasSeveralElements
%Например, в языке Java \lstinline{ImportList} состоит из массива \lstinline{ImportStatement}. 
%Полученные текстовые представления для каждого \lstinline{ImportStatement} необходимо объединить, расположив их друг под другом, таким образом получив текстовое представление \lstinline{ImportList}.

Все указанные выше свойства можно получить прямо из грамматики языка.
\noindent
Название компоненты, класса синтаксического анализатора, метода для получение поддерева задаются с использованием логики генератора синтаксического анализатора.
Поддеревьями будут являться нетерминалы в правой части. %, их имена могут быть произвольными, но должны быть понятны пользователю системы.
Поддерево будет обязательным, если оно не является элементом выбора (\emph{A} $\rightarrow$ \emph{B} | \emph{C} | \emph{D}), элементом с условным вхождением (``?''~--- 0 или 1) или элементом с повторением (``*''~--- любое число раз).
Если нетерминал в правой части допускает множественное вхождение (``+''~--- 1 или более раз, ``*''~--- любое число раз), то считается, что поддерево состоит из нескольких элементов.

Ниже приведено правило грамматики языка While, задающее ту же структуру языка, что и описание на рис.~\ref{mth:whileComponent}:
{
\lstinputlisting{Ozernykh/codes/whileRule.txt}
}
\noindent
Данное правило грамматики имеет два нетерминала в правой части \lstinline{bexpr} и \lstinline{stmt_list}.
При этом конструкция в правой части не является выбором (\emph B | \emph C | \emph D), и каждый из нетерминалов не имеет условного или множественного вхождения.
Таким образом, мы получаем те же данные, что указаны на рис.~\ref{mth:whileComponent}.

\subsection{Необходимые преобразования правил грамматики}%Фильтрация правил}
Грамматика языка содержит множество правил, однако некоторые из них могут не иметь представления в синтаксическом дереве или быть ненужными с точки зрения принтера.
Генерация компонент принтера по таким правилам может привести к его некорректности или увеличению времени его работы.
Чтобы полученный принтер был корректным и производительным, необходимо определить набор правил, задающих структуры языка, которые могут иметь различные текстовые представления, то есть будут форматироваться принтером.
Такие правила будем называть \emph{значимыми} (в контексте принтера).
Остальные правила назовём \emph{избыточными}, так как для них либо существует одно текстовое представление, либо не существует никакого.
Поэтому генерация кода принтера для них бессмысленна, так как увеличивается время работы и генератора, и принтера.

% а может, ну их?
%\subsubsection{Удаление цепных правил}
%Будем убирать цепные правила грамматики
%Избыточными правила являются цепные правила грамматики~-- упорядоченные пары (\emph{A}, \emph{B}), в которых \emph{A} $\xRightarrow{\text{*}}$ \emph{B}, используя только цепные правила.
%Существует алгоритм \cite{book:ulman} устранения цепных правил, причем
%\begin{itemize}
%    \item найти все цепные правила в грамматике;
%    \item для каждой цепной пары (\emph{A}, \emph{B}) добавить в грамматику все правила вида \emph{A} $\Rightarrow$ $\alpha$, где \emph{B} $\Rightarrow$ $\alpha$~--- нецепное правило грамматики;
%    \item удалить все цепные правила.
%\end{itemize}
%\noindent
%Такое 
%такое преобразование грамматики корректно, так как не меняет язык.
%Полученные правила %вида \emph{A} $\Rightarrow$ $\alpha$ 
%будут считаться значимыми, если пройдут дальнейшую фильтрацию.
%% =======================
%% НИ О ЧЕМ
%% =======================

\subsubsection{Устранение левой рекурсии}
Как уже было отмечено, грамматика, с которой работает Grammar-Kit, не может иметь леворекурсивных правил (непосредственная левая рекурсия: \emph{A} $\rightarrow$ \emph{A}$\alpha$).
Существует способ устранения левой рекурсии \cite{book:ulman}, однако при этом создаются вспомогательные правила, которые не имеют представления в синтаксическом дереве, а значит, не могут иметь и текстового представления.
Такие правила также считаются избыточными.
%но такое преобразование порождает множество новых правил (именно в таком виде правило будет представлено в грамматике).
%С точки зрения принтера они являются избыточными, а мы будем рассматривать только сам нетерминал \emph{A}.

\subsubsection{Другие правила грамматики}
Грамматика языка может содержать особые правила, которые должны помечаться специальными модификаторами.
Среди них: \emph{private}, \emph{external} ~--- для правил с такими модификаторами не генерируются классы внутреннего представления.
%Так как компоненты принтера взаимодействуют с узлами синтаксического дерева, то и генерация компонент по таким правилам не нужна.
Так как компоненты принтера зависят от классов внутреннего представления и их методов, то генерация компонент по таким правилам не нужна.
%В таком случае генерация компоненты принтера не нужна.

\subsection{Поиск правил, описывающих списочных структуры}
%% ==================================
%% hasSeveralElements
%% ==================================
Все структуры языка можно разделить на содержащие списочные поддеревья и не содержащие.
Например, структура ``вызов метода'' имеет поддерево ``список параметров''.
В статье \cite{paper:while} описываются особенности форматирования таких структур, поэтому их необходимо обрабатывать иным образом, то есть генерировать другой код.
Для этого необходимо заранее знать, какая перед нами структура.
Из грамматики языка мы не можем узнать, являются ли поддеревья данной структуры списками.
Для решения этой проблемы в грамматику был введен новый модификатор для правил \emph{list}.
Предполагается, что пользователь системы найдет списочные правила в грамматике и отметит их вручную.
Также списки в некоторых языках могут иметь отличные от запятой разделители: ``;'', ``|''~-- и другие.
Поэтому пользователю предлагается указывать еще и тип разделителя для списочной структуры, задаваемой данным правилом, если этот разделитель отличен от запятой.
Для этого требуется указать значение параметра \lstinline{listSep}:

{
\begin{lstlisting}
list alt_list ::= expr ('|' expr)* { listSep='|' }
\end{lstlisting}
}
%Такое указание типа правила позволяет явно задать шаблон для генерации компоненты принтера.
\subsection{Итоги}
Таким образом, было установлено соотношение между XML-описаниями, использовавшимися для задания компонент принтера, и правилами грамматики, что позволяет получить требуемую нам информацию.
Из всего множества правил были выделены те, которые задают структуры, форматирование которых будет изменяться.
По полученному множеству правил далее будут генерироваться компоненты принтера.
