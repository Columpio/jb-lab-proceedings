\section*{Введение}
\lstset{basicstyle=\normalsize\ttfamily, columns=fullflexible}

% про IDE
Интегрированные среды разработки (Integrated Development Environment, IDE) являются неотъемлемой частью современного программирования и разработки программных продуктов. 
Появившись в 1970-х годах, они прошли длительный путь развития и совершенствования. 
В наши дни типичная среда разработки включает в себя текстовый редактор, компилятор и/или интерпретатор, средства автоматической сборки, отладчик и другие инструменты. 
Популярными IDE для языка Java являются Eclipse\footnote{\texttt{https://eclipse.org}} и IntelliJ IDEA\footnote{\texttt{http://jetbrains.com/idea}}.
Они также включают средства для работы с системами контроля версий, рефакторинга, форматирования кода. 
Кроме того, существует возможность расширения функциональности этих IDE путем создания плагинов~--- программных компонентов, добавляющих новые возможности.
В частности, плагины могут добавлять поддержку новых языков в IDE.
Для разработки подобного плагина необходимо в большинстве случаев реализовать синтаксический анализатор целевого языка, который в случае IntelliJ IDEA можно получить с помощью плагина Grammar-Kit по грамматике этого языка в форме Бэкуса-Наура.
%Чтобы создать такой плагин, необходимо так же иметь синтаксический анализатор, который, в случае IntelliJ IDEA, можно получить с помощью плагина Grammar-Kit по грамматике этого языка в форме Бэкуса-Наура.
Также, при реализации поддержки нового целевого языка часто возникает потребность в реализации форматера для программ на этом языке.
%Некоторые IDE так же имеют средства для работы с системами контроля версий, рефакторинга и форматирования коода, поддержки новых языков и пр., причем количество этих средств постоянно растет. 
%Популярными IDE для языка Java являются Eclipse\footnote{\texttt{https://eclipse.org}} и IntelliJ IDEA\footnote{\texttt{http://jetbrains.com/idea}}.
%Эти среды имеют возможности расширения функциональности путем создания плагинов~--- программных компонентов, добавляющих новые возможности. 
%В частности, плагины могут добавлять поддержку новых языков в IDE.
%Чтобы создать такой плагин, необходимо так же иметь синтаксический анализатор, который, в случае IntelliJ IDEA, можно получить с помощью плагина Grammar-Kit по грамматике этого языка.
%Для каждой из этих сред существует большое сообщество пользователей, которые создают плагины, тем самым развивая и совершенствуя их.
%Одним из таких направлений развития является разработка средств для автоматического форматирования программного текста.
% * <podkoav239@gmail.com> 17:11:09 25 Apr 2016 UTC+0300:
% Очень коряво. Надо зайти к теме форматирования по-другому.

Задача автоматического форматирования текстов программ является классической в области разработки языковых процессоров.
%, в том числе и средств интегрированной разработки. %%подумать
Она подразумевает построение текста программы по ее синтаксическому дереву или дереву разбора.
Для каждого дерева существует множество различных текстовых представлений.
Так, на рис.~\ref{fig:ifTree} приведен пример синтаксического дерева оператора ветвления языка C, а на рис.~\ref{intro:treeToCode} различные текстовые представления этого дерева.
\begin{figure}[h]
	\centering
	\includegraphics[width=.55\textwidth]{Ozernykh/images/ifTree.png}
	\caption{Оператор ветвления в виде дерева разбора}
	\label{fig:ifTree}
\end{figure}
\noindent
\fvset{frame=lines,framesep=7pt}
\begin{figure}[ht]
  \noindent
  \begin{minipage}{.4\textwidth}
    \lstinputlisting[language=Java]{Ozernykh/codes/treeToCode1.txt}
    \vspace{1cm}
    \caption*{а) }    
  \end{minipage}
  \hfill
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[language=Java]{Ozernykh/codes/treeToCode2.txt}
    \caption*{б)}    
  \end{minipage}
  \caption{Текстовые представления синтаксического дерева с рис.~\ref{fig:ifTree}}
  \label{intro:treeToCode}
\end{figure}
\noindent
Программный компонент, занимающийся форматированием, мы будем называть \emph{принтером}.
Как правило, результат работы принтера должен соответствовать некоторому \emph{стандарту кодирования} (СК, coding convension)~--- набору правил и соглашений, используемых при написании кода на соответствующем языке программирования.
Так, стандарт кодирования для языка Java задает расположение фигурных скобок и операторов внутри тела функции, размер и формат отступов и др.

%Еще одним способом 
Одним из способов форматирования программных текстов является метод, основанный на \emph{синтаксических шаблонах}~\cite{paper:while}. %podkopaev:diploma
Под \emph{шаблоном} понимаются данные, сопоставление которых с элементом синтаксического дерева дает текстовое представление этого элемента (и его потомков). 
%\noindent 
На рис.~\ref{fig:templatecodeintro}, \emph{а} представлен шаблон форматирования, который может быть применен к дереву разбора с рис.~\ref{fig:ifTree}.
%%
%% =============================================================================
%% ФАКТИЧЕСКАЯ ОШИБКА 
%% =============================================================================
%%
%Он содержит метки вида \lstinline{@text}, которые используются для вставки соответствующих поддеревьев (\lstinline{@condition}~--- условие, \lstinline{@exprM}~--- поддерево, соответствующее выполнению условию и содержащее несколько (M) подвыражений, \lstinline{@exprS}~--- поддерево, соответствующее невыполнению условия и содержащее одно (S)подвыражение).
%(несколько подвыражений, соответствующих выполнению условия, и одно подвыражение, соответствующее невыполнению условия).
На рис.~\ref{fig:templatecodeintro}, \emph{б} представлен результат применения шаблона к этому дереву.
% * <podkoav239@gmail.com> 17:15:41 25 Apr 2016 UTC+0300:
% Хотелось бы чуть подробнее.

%\vspace{.3cm}
%\fvset{frame=lines,framesep=7pt}
%\begin{minipage}{.4\textwidth}
%  \lstinputlisting[language=Java]{codes/ifTemplateIntro.txt}
%  \caption{Шаблон для оператора ветвления}
%  \label{code:ifTemplateIntro}
%\end{minipage}
%\hfill
%\begin{minipage}{.5\textwidth}
%  \lstinputlisting[language=Java]{codes/ifCodeIntro.txt}
%  \caption{Текст, полученный при применении шаблона к дереву разбора}
%  \label{code:ifCodeIntro}
%\end{minipage}
% пока так
\fvset{frame=lines,framesep=7pt}
\begin{figure}[ht]
  \noindent
  \begin{minipage}{.4\textwidth}
    \lstinputlisting[language=Java]{Ozernykh/codes/ifTemplateIntro.txt}
    \caption*{а) Шаблон для оператора ветвления}    
  \end{minipage}
  \hfill
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[language=Java]{Ozernykh/codes/ifCodeIntro.txt}
    \caption*{б) Текст, полученный при применении шаблона к дереву разбора}    
  \end{minipage}
  \caption{Оператор ветвления и шаблон для него}    
  \label{fig:templatecodeintro}
\end{figure}


% * <podkoav239@gmail.com> 17:16:40 25 Apr 2016 UTC+0300:
% И вообще здесь лчше обойтись без оформления \begin{figure} ... \end{figure} как я сделал в статье.

%Данный подход был апробирован
Такой подход был применен в работе~\cite{paper:while} при разработке принтер-плагина для среды разработки IntelliJ IDEA. %\cite{paper:while}.%, podkopaev:diploma}.
На рис.~\ref{intro:howto} приведен процесс работы принтер-плагина. 
На вход принтеру подаются содержащий требуемое форматирование код (эталонный репозиторий), из которого извлекаются шаблоны форматирования, и код, который необходимо отформатировать (целевой код).
Полученные шаблоны применяются к целевому коду, и результатом работы принтера становится отформатированный целевой код.

%На вход принтеру подается код, содержащий требуемое форматирование (эталонный репозиторий), и код, которые необходимо отформатировать (целевой код). Затем из эталонного репозитория извлекаются шаблоны форматирования и 
%Входными данными для принтера является код, форматирование которого нам интересно (эталонный репозиторий), и код, который нужно отформатировать (целевой код).
%Из образца извлекаются синтаксические шаблоны, которые затем применяются к целевому коду (рис.~\ref{intro:howto}).

%Входными данными для принтера является репозиторий, форматирование которого необходимо изменить, а так же репозиторий-образец, в котором хранится код с целевым форматированием.
\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{Ozernykh/images/ppusage2.png}
    \caption{Принцип работы принтер-плагина}
    \label{intro:howto}

% * <podkoav239@gmail.com> 12:07:04 03 May 2016 UTC+0300:
% Картинку привести в соответствие с текстом, перерисовать, как и обсуждали.
\end{figure}

%Количество языков, которые поддерживаются принтер-плагином, можно увеличить.
%IntelliJ IDEA поддерживает широкий набор языков, поэтому необходимо, чтобы принтер-плагин позволял форматировать программы на разных языках программирования.
Список поддерживаемых принтер-плагином языков можно расширять.
Для этого необходимо создать языкозависимую прослойку между ядром платформы и представлением синтаксического дерева, полученного в результате работы анализатора.
Метод, описанный в~\cite{paper:while}, позволяет генерировать такую прослойку по языкозависимому описанию \emph{компонент принтера}~--- классов, описывающих, как форматировать соответствующие элементы синтаксического дерева.
Описание каждой компоненты принтера (\lstinline{component}) является XML-файлом. Каждый такой файл содержит имя компоненты (\lstinline{name}), класс внутреннего представления в IDE (\lstinline{psiComponentClass}), %имя метода, преобразующего текст в объекты, которыми оперирует система , 
а так же список поддеревьев (\lstinline{subtree}) и их свойств (\lstinline{name}, \lstinline{psiGetMethod}, \lstinline{hasSeveralElements}, \lstinline{isRequired}).
На рис.~\ref{intro:whileComponent} приведено XML-описание компоненты принтера, соответствующей циклу с предусловием.
%%
%% =============================================================================
%% В СООТВЕТСТВИЕ С КАРТИНКОЙ ПРИВЕСТИ (где ссылка на листинг)
%% =============================================================================
%%
Современные языки программирования содержат большое число структур, поэтому необходимо большое число подобных XML-описаний для задания принтера языка.
%следовательно, необходимо большое число таких описаний.
%Чтобы получить принтер нового целевого языка, необходимо вручную реализовать языкозависимую прослойку между ядром платформы и представлением синтаксического дерева, полученного в результате работы анализатора.
%Существующее решение для реализации такой прослойки ~--- создание языконезависимого описания (рис.~\ref{intro:whileComponent}) \emph{компонент принтера} (классов, описывающих, как форматировать соответствующие элементы синтаксического дерева) с последующей генерацией этих компонент~\cite{paper:while}.
\begin{figure}[t]
    \lstinputlisting[language=XML]{Ozernykh/codes/whileComponent.txt}
    \caption{Описание компоненты принтера, форматирующей циклы с предусловием}
    \label{intro:whileComponent}
\end{figure}
\noindent
Процесс создания такого описания трудоемок и требует глубоких знаний о системе~\cite{paper:while}.

Грамматика языка, которая используется в Grammar-Kit и по которой генерируется код синтаксического анализатора, содержит большую часть необходимой информации для создания этой языкозависимой прослойки.
Поэтому принтер для целевого языка можно получать по грамматике этого языка.
