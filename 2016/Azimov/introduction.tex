% У введения нет номера главы
\section*{Введение}

При разработке сложных программных систем существует проблема недостатка выразительности и гибкости языков программирования общего назначения. Часто для решения данной проблемы помимо основного языка используют один или несколько других (встроенных) языков. В данном подходе программа, написанная на основном языке, динамически формирует строковое представление кода на встроенном языке, и далее сформированная строка анализируется и выполняется специальными компонентами (базы данных, веб-браузер) во время исполнения основной программы.

Как правило, динамически формируемые выражения, описывающие код программ на встроенных языках, конструируются с использованием конкатенаций строковых литералов в ветках условных операторов, циклах и рекурсивных процедурах. Это приводит к множеству возможных значений встроенного кода, что не позволяет в общем виде использовать статический анализ для проверки корректности формируемого выражения. В результате этого становятся недоступными такие типы функциональности, как информирование о синтаксических ошибках, автодополнение и подсветка синтаксиса. Отсутствие этих возможностей повышает вероятность ошибок, которые обнаруживаются лишь во время выполнения программы, а также усложняет процесс разработки и тестирования.

Существует ряд инструментов, позволяющих проводить анализ динамически формируемых строковых выражений: Java String Analyzer~\cite{JSA,JSAUrl}, PHP String Analyzer~\cite{PHPSA}, Alvor~\cite{Alvor1, Alvor2, AlvorUrl}, IntelliLang~\cite{IntelliLang}, PHPStorm~\cite{PHPStorm}, Varis~\cite{Varis} (анализ этих технологий приведен в работе~\cite{SemonPHD}). Большинство реализаций проводят диагностику синтаксических ошибок, но плохо расширяемы: как в смысле поддержки других языков, так и в смысле решения новых задач. Существует алгоритм, описанный в статье~\cite{ARNGLR} и реализованный как часть проекта YaccConstructor~\cite{YC}, который позволяет провести синтаксический анализ динамически формируемых выражений. В отличие от других инструментов, реализация данного алгоритма хорошо расширяема и строит конечное представление леса разбора относительно входной грамматики, которое может быть использовано в дальнейшем семантическом анализе. Недостаток данного алгоритма заключается в отсутствии механизма диагностики синтаксических ошибок. Устранению этого недостатка и посвящена данная работа.
