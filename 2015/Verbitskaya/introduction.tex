% У введения нет номера главы
\section*{Введение}
Существует множество программ, которые динамически формируют выражения на  некотором языке из строковых литералов с помощью строковых операций, и передают эти выражения специальным компонентам времени исполнения для дальнейшего анализа и выполнения. Такие программы мы называем \emph{генераторами}; динамически формируемые выражения будем называть \emph{встроенным кодом} или \emph{выражениями на встроенном языке}. Множество средств предоставляют возможность использовать встроенный код, например: динамический SQL (Dynamic SQL~\cite{DSQLISO}), фреймворк JSP~\cite{JSP}, PHP mySQL interface~\cite{PHPmySQL}. 

Достоинствами использования такой динамической генерации кода являются гибкость, выразительность и высокая производительность полученных программ. Однако этот подход делает поведение программы гораздо менее предсказуемым за счёт невозможности применения стандартных для многих языков программирования видов статического анализа. Например, во время компиляции основной программы стандартными средствами не представляется возможности провести синтаксический анализ формируемых выражений. Данное обстоятельство делает невозможным вычисление семантики, и, как следствие, не позволяет решить многие классические задачи статического анализа программного кода, такие как проверка корректности типов или определение неинициализированных переменных. Помимо влияния на надёжность системы, использование встроенных языков значительно усложняет разработку и понимание ранее написанного кода, а также его отладку. 

Преодолеть многие проблемы такого подхода позволяет статический анализ множества значений динамически формируемого выражения. Одним из примеров такого анализа  является проверка соответствия формируемых выражений некоторой эталонной  грамматике. Например, если речь идёт о встраивании SQL-выражений в код на PHP,  необходимо проверить, что все порождаемые выражения действительно принадлежат  языку SQL. Множество значений динамически формируемого выражения является  языком $L$. Задача проверки корректности строк языка $L$ формализуется как задача проверки его вложенности в эталонный язык $L_{r}$. Как правило, язык, на котором написана основная программа, является тьюринг-полным, вследствие чего язык $L$ может быть рекурсивно перечислимым, что делает задачу проверки вложенности языков алгоритмически неразрешимой. Распространённый подход к анализу встроенных языков заключается в анализе множества, аппроксимирующего сверху (over-approximation) множество порождаемых выражений~\cite{Stranger,JSA,Alvor,Alvor2}. Например, если аппроксимирующее множество $L_{a}$ -- регулярный язык, а эталонный язык $L_{r}$ относится к классу детерминированных контекстно-свободных, задача проверки $L_{a} \subseteq L_{r}$ разрешима~\cite{LangInclusion}. Данные рассуждения используются во многих существующих подходах к анализу динамически формируемых выражений. 

Несмотря на то, что вычисление семантики можно производить одновременно с синтаксическим анализом, часто оказывается удобнее работать со структурным представлением исходного кода. Таким представлением может являться лес деревьев вывода формируемых выражений. Однако непосредственная генерация таких деревьев невозможна по причине необходимости экспоненциального количества ресурсов, а также заранее неограниченной высоты таких деревьев, например, в случае формирования выражения через конкатенацию в цикле. Таким образом, необходимо некоторое  представление леса вывода, имеющее конечный размер. Алгоритмы синтаксического анализа семейства Generalized LR, предназначенные для работы с произвольными, в том числе неоднозначными, контекстно-свободными грамматиками, строят сжатый лес разбора (Shared Packed Parse Forest, SPPF~\cite{SPPF}), компактно представляющий все возможные варианты разбора входной цепочки. В случае анализа встроенных языков SPPF может быть использован как компактное представление леса разбора строк аппроксимирующего множества $L_{a}$. \newpage