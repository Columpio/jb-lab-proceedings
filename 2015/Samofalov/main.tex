\title{Библиотека почти точной копирующей сборки мусора для C++}

\titlerunning{Библиотека почти точной сборки мусора}

\author{Самофалов Александр Владимирович}

\authorrunning{A.В.Самофалов}

\tocauthor{A.В.Самофалов}
\institute{Санкт-Петербургский государственный университет\\
\email{aleksander.samofalov@gmail.com}}

\maketitle             

\begin{abstract}
В работе описывается реализация почти точной копирующей сборки мусора
в виде библиотеки для языка С++. Такой подход позволяет избирательно 
использовать сборку мусора независимо от компилятора. Библиотека 
предоставляет интерфейс к управляемой подсистеме памяти в форме
``умного'' указателя и сравнима по эффективности со стандартными
``умными'' указателями.
\end{abstract}

\section*{Введение}
Память является одним из самых критических ресурсов приложения: неправильная работа с ней
может привести к значительной потере производительности или даже к ошибкам в
работе программы. Для объектов, размер которых неизвестен во время компиляции, нельзя выделить память статически. Поэтому существует специальная область памяти, называемая кучей (\textit{heap}),
в которой возможно выделить память во время исполнения программы, обратившись к специальному менеджеру.

Так как память, доступная приложению, ограничена, то полученные области памяти должны быть освобождены и возвращены обратно куче. В самом простом случае используется ручное управление памятью, при котором обязанность по выделению и освобождению памяти ложится на программиста. Но, во-первых, ручное управление памятью не всегда удобно.
Например, при использовании некоторых функциональных языков программирования очень сложно
определить время жизни объекта, а значит, и момент, когда нужно освобождать занимаемую им память. Во-вторых, программисты допускают ошибки в управлении памятью,
которые могут привести к неправильной работе программы. 

Одна из самых распространённых проблем в управлении памятью~--- это ``утечки памяти''~(\textit{memory leak}), 
которые возникают, если какая-нибудь область памяти после использования не была
освобождена и стала недоступной для приложения. При управлении памятью также встречается проблема фрагментации, возникающая при невозможности выделить непрерывный блок нужного размера,
несмотря на то, что суммарное количество свободной памяти превосходит этот размер. 
Еще одной распространенной проблемой являются ``висячие ссылки''~(\textit{dangling pointers})~--- указатели на освобожденные области памяти.

Некоторые проблемы ручного управления памятью решает автоматическое управление памятью, или сборка мусора (\textit{garbage collection}). 
Сборщик мусора обходит память приложения, определяет недоступные для программы
объекты в куче и освобождает их. Недоступными считаются объекты, на которые нет указателей из корневого множества, под которым понимаются объекты на стеке и глобальные переменные. Сборка мусора является точной, если она правильно обнаруживает все недоступные объекты. Точная сборка мусора возможна при соблюдении следующих условий:
\begin{enumerate}
\item{Сборщик мусора должен правильно строить корневое множество.}
\item{Сборщик мусора должен правильно определять все указатели внутри объектов.}
\end{enumerate}
Если хотя бы одно из условий не выполняется, то возможна только консервативная сборка мусора. В этом случае используются некоторые эвристики для 
обнаружения указателей на объекты.

Использование сборки мусора имеет недостатки. Главным из этих недостатков являются
высокие накладные расходы: например, многие сборщики мусора приостанавливают приложение
на время своей работы, что может существенно ухудшить производительность данного приложения. Тем не менее, для некоторых приложений может быть критична не производительность, а другие свойства. Поэтому
существует множество различных алгоритмов сборки мусора. Среди них можно выделить копирующие сборщики мусора, которые позволяют уменьшить фрагментацию памяти за счёт того, что после цикла своей работы копируют все выжившие объекты в один непрерывный блок памяти.

С++~--- популярный язык общего назначения, широко используемый
для разработки приложений, для которых производительность является критичной, а 
также для различных низкоуровневых приложений. К сожалению, спецификация C++ не предусматривает использования сборки мусора. Тем не менее, реализации сборщика мусора
для этого языка существуют~\cite{mcc1, boehm1}. Большинство из них являются консервативными, хотя хотелось 
бы иметь точный сборщик мусора для C++.

В рамках проекта лаборатории JetBrains\footnote{https://www.jetbrains.com} на математико-механическом факультете СПбГУ
была реализована библиотека сборки мусора для языка C++~\cite{berezun}. 
Реализованный сборщик мусора является неконсервативным, не требует поддержки от компилятора, не запрещает использовать какие-либо конструкции языка, но накладывает некоторые ограничения на программу.

К сожалению, у этой библиотеки имеются недостатки. Целью данной работы является устранение недостатков данной библиотеки. Для этого были поставлены следующие задачи: 
\begin{itemize}
\item исправление ошибок в работе с объектами; 
\item добавление поддержки многопоточности;
\item реализация сжимающего алгоритма сборки мусора;
\item тестирование и апробация полученной реализации.
\end{itemize}


\section{Существующие методы автоматического управления памятью в C++}
Сборка мусора была впервые применена для языка Lisp~\cite{lisp} в 60-х годах XX века. На сегодняшний день технология сборки мусора широко используется в таких популярных языках, как Java\footnote{http://java.com}, OCaml\footnote{http://ocaml.org}, Python\footnote{http://www.python.org}.

Однако, как уже отмечалось ранее, несмотря на популярность языка C++, его стандарт не предусматривает использование сборки мусора. Тем не менее, было сделано несколько попыток реализации сборщика мусора для C++. Различные подходы к автоматическому управлению памятью будут описаны далее.

\subsection{Сборщик мусора Бёма-Демерса-Вайзера}
Одним из самых известных сборщиков мусора для C++ является сброщик мусора Бёма-Демерса-Вайзера (Boehm-Demers-Weiser garbage collector)~\cite{boehm1, boehm2, boehm3}. Этот сборщик мусора является консервативным: машинное слово считается указателем, если оно является адресом внутри какого-нибудь объекта в куче. Этот сборщик мусора работает за счёт того, что заменяет функции выделения и освобождения памяти на свои специальные функции. Эти функции, кроме работы с памятью, сохраняют необходимую для сборки мусора метаинформацию.

Одна из главных целей, которые ставилась перед разработчиками этого сборщика мусора~--- совместимость с существующими программами на языке C++ без необходимости что-либо менять в исходном коде приложения. Этот сборщик  мусора накладывает минимальные ограничения на работу программы. Для работы с ним достаточно динамически загрузить библиотеку со сборщиком мусора во время запуска приложения. Также сборщик мусора Бёма-Демерса-Вайзера обладает функциональностью поиска утечек памяти в приложении.

Основным недостатком этого сборщика мусора является его консервативность. Из-за консервативности он не всегда способен идентифицировать весь мусор и, соответственно, очистить память из-под него. Следствием этого могут стать задержки в работе менеджера памяти, сборщика мусора или даже исчерпание памяти. 

\subsection{Почти копирующий сборщик мусора}
Другим консервативным сборщиком мусора для языка С++ является почти копирующий сборщик мусора (\textit{Mostly Copying Collector})~\cite{mcc1, mcc2}. 
Данный сборщик мусора является копирующим, что имеет некоторые преимущества по сравнению с остальными алгоритмами, например, более быстрое выделение памяти и уменьшение фрагментации кучи. В почти копирующем сборщике мусора вся память, доступная куче, делится на две области~--- старую (\textit{old}) и новую (\textit{next}). Во время сборки мусора все обнаруженные достижимые объекты копируются из старой области памяти в новую, а во всех указателях адрес этих объектов заменяется на новый. После сборки мусора области меняются местами. 

Так как этот сборщик является консервативным, то он не всегда может определить указатели. Если сборщик мусора не уверен, является ли данное машинное слово указателем, оно считается неявным корнем, а объект, на который оно указывает, переносится в новую область без копирования. Для того, чтобы это было возможно, области памяти представлены не непрерывными блоками памяти, как в самом простом mark-and-compact алгоритме~\cite{lisp-copy}, а разделены на несвязанные участки памяти. Из вышесказанного следует, что этот сборщик мусора показывает хорошие результаты, только когда он способен точно находить большой процент указателей.

Для того, чтобы приложение работало с данным сборщиком мусора, необходимо его собрать вместе с библиотекой сборщика, а также использовать предоставляемые ей методы для выделения и освобождения памяти. Также для улучшения работы сборщика мусора пользователь может отметить указатели внутри собственных структур данных.

\subsection{``Умные указатели''}
Под ``умными'' указателями понимаются классы, которые имитируют работу указателя. За счёт различных механизмов они способны автоматически освобождать память.

Одним из типов умных указателей является указатель единоличного владения (\textit{unique pointer}). Данный указатель реализует идиому ``получение ресурса есть инициализация'' (\textit{Resource Acquisition Is Initialization}), которая заключается в том, что выделение памяти под объект происходит во время инициализации ``умного'' указателя. Когда ``умный'' указатель уничтожается, он в своём деструкторе освобождает выделенную память. Для того, чтобы память из--под объекта не была освобождена дважды, для данного указателя запрещено копирование. Владение над объектом можно только передать другому указателю.

К сожалению, данный указатель нельзя использовать, если у объекта есть несколько различных владельцев~--- например, при использовании одного ресурса из разных потоков. Для решения данной проблемы существует указатель раздельного владения (\textit{shared pointer}). 
При применении этого умного указателя используется подсчёт ссылок~--- с каждым объектом ассоциируется дескриптор, в котором хранится число ссылающихся на этот объект указателей. При инициализации указателя счётчик увеличивается, при уничтожении уменьшается. При присваивании указателю нового значения счётчик соответствующий старому значению уменьшается, а для нового значения увеличивается. Если в какой-то момент счётчик стал равным нулю, то память из-под него освобождается, так как это означает, что никто больше не ссылается на этот объект.

Несмотря на то, что подсчёт ссылок является широко распространённой техникой, он имеет существенный недостаток~--- неспособность работать с циклическими ссылками. Если два объекта ссылаются друг на друга, то их счётчики ссылок содержат, как минимум, по одному объекту, а значит, не станут равными нулю, и память из-под них не будет освобождена. Эта проблема разрешается с помощью невладеющих указателей (\textit{weak pointer}), отличающихся от указателей раздельного владения тем, что не влияют на счётчик ссылок объекта, на который  они указывают. Однако забота о правильном и своевременном использовании невладеющих указателей является ответственностью программиста.

Существует множество реализаций умных указателей в различных библиотеках, например в boost\footnote{http://www.boost.org}, Qt\footnote{http://www.qt.io}. Начиная со стандарта C++11 вышеописанные умные указатели были добавлены в стандартную библиотеку языка C++, в которой реализованы на основе библиотеки boost.

\subsection{Библиотека неконсервативной сборки мусора}
Умные указатели можно использовать для реализации сборщика мусора. Одной из таких реализаций является библиотека неконсервативной сборки мусора, которая была написана в лаборатории JetBrains.
Данная реализация использует умные указатели для того, чтобы строить корневое множество, а также для определения указателей внутри объектов. Пользователю для корректной работы с этим сборщиком мусора необходимо использовать эти умные указатели, а также предоставленные функции выделения памяти.
Библиотека также позволяет работать одновременно и с объектами, управляемыми сборщиком мусора, и с управляемыми вручную пользователями. Также библиотека предоставляет интерфейс для перевода объектов из управляемых в ручные и обратно.

В отличие от некоторых других реализаций сборщика мусора на умных указателях, данная библиотека не накладывает ограничений на используемое множество языка.
Также пользователю не нужно указывать расположение указателей внутри объекта~--- сборщик мусора находит их самостоятельно.

К сожалению, данный сборщик мусора имеет недостатки. Во-первых, он не поддерживает многопоточность и корректно работает только для программ, использующих один поток. Во-вторых, данная реализация использует самый простой алгоритм сборки мусора~--- mark-and-sweep, который проигрывает более ``продвинутым'' алгоритмам.
В-третьих, реализация имеет высокие накладные расходы на сканирование полей объекта при его создании для обнаружения указателей.

Данная работа посвящена развитию описанной выше библиотеки.


\section{Реализация}
В данном разделе описана работа по устранению недостатков библиотеки.
\subsection{Работа с объектами}
C++~--- мультипарадигменный язык, который поддерживает
объектно-ориентированное программирование. В данной парадигме одним из основных
понятий является объект~--- сущность, которая, используя свои данные, может реагировать
на посылаемые ей сообщения. В C++ посылка и приём сообщений реализованы с помощью методов~--- 
функций, которые определяют, какие действия может выполнять объект. 
Большинство методов имеют неявный аргумент \textit{this}~--- указатель на объект,
у которого вызывается данный метод. 

Во время изучения возможностей библиотеки неконсервативной сборки мусора была обнаружена ситуация при работе с объектами, которая приводит к ошибкам в работе программы. Рассмотрим следующущий пример, который лучше всего иллюстрируется кодом в листинге~\ref{danya-fail}.

\begin{lstlisting}[caption = Пример ошибки\label{danya-fail},language=Java]
class B {
    gc_ptr<A> a;
}

class A {
    void f() {
        b->a = NULL;
        // gc
        g();
    }
    
    void g() {
        ...
    }
}
\end{lstlisting}


На объект \textit{A} существует единственный управляемый указатель из объекта \textit{B}. Если в процессе выполнения какого-нибудь метода \textit{A} этот указатель перестанет указывать на \textit{A}, и сразу после этого будет совершена
сборка мусора, то сборщик мусора посчитает \textit{A} недостижимым, и память из-под него
будет освобождена. Однако приложение может обратиться к объекту с помощью
указателя \textit{this}, что и приводит к ошибке.

Для решения данной проблемы необходимо хранить все ссылки на \textit{this},
которые находятся на стеке, но C++ не предоставляет возможности для этого. 
Для того, чтобы вызвать метод у объекта, на который
указывает управляемый указатель, сначала нужно получить ``сырой'' указатель на этот
объект. При получении этого ``сырого'' указателя, он сохраняется в специальную структуру данных~--- хэш-таблицу для разыменованных указателей.
Это происходит не только при вызове метода у объекта, но и при обращении к одному из
его полей, но далее мы увидим, что это будет также полезно.

При сборке мусора для обнаружения достижимых объектов используются не только 
управляемые указатели, но и стек приложения. Для этого обходится каждое слово стека.
Если слово содержится в хэш-таблице разыменованных указателей, то этот указатель считается корнем, и все объекты, достижимые от него, являются живыми.

После того, как метод выполняется полностью, объект перестаёт быть доступным из
указателя \textit{this} этого метода. Этот момент сборщик мусора не может отследить,
поэтому можно считать, что выполняется следующее приближение: после завершения сборки мусора, из
хэш-таблицы разыменованных указателей удаляются все указатели, которые не были найдены на стеке.

Данная процедура является консервативной, то есть возможна ситуация при которой не весь мусор будет найден. Но такая ситуация является очень редкой: для её воспроизведения необходимо чтобы, во-первых, не осталось никаких указывающих на объект указателей и, во-вторых, при этом на стеке было расположено число равное его адресу. Поэтому сборщик мусора можно назвать ``почти точным''.

Во время работы программы может произойти такая ситуация, что сборка мусора не вызывается длительное время, но количество разыменованных указателей продолжает увеличиваться. Это приводит к тому, что следующий запуск сборщика мусора будет работать очень долгое время. Чтобы этого избежать, при достижении хэш-таблицы разыменованных указателей некоторого размера происходит его очистка: обходится стек исполнения, и из таблицы удаляются все объекты, которые не были найдены на стеке.
\subsection{Многопоточность}
Большинство промышленных приложений являются многопоточными. Поэтому поддержка многопоточности в сборщике мусора является естественным требованием. Исходная библиотека сборки мусора это требование не выполняла~--- она корректно работала только с выполняющимися в одном потоке программами. В данном разделе подробно описывается реализация поддержки многопоточности.

\subsubsection{Работа с потоками.}
Для построения корневого множества библиотека использует структуры данных, которые
хранят управляемые указатели и разыменованные указатели. Эти структуры являются глобальными, и их использование в многопоточном приложении может привести к ошибкам, так как несколько потоков могут одновременно обратиться к ним.
Для решения этой проблемы было решено создать для каждого потока свой экземпляр этих структур. Для реализации была использована возможность C++11 указывать
глобальные переменные как локальные для потока (\textit{threadlocal}).

В C++ не существует стандартной реализации поддержки многопоточности. 
Однако самой распростаненной из них является POSIX Threads(\textit{pthreads})~\cite{pthreads}. Поэтому было решено добавить поддержку многопоточности в сборщике мусора на основе этой библиотеки.

Для сборки мусора в многопоточном окружении необходимо знать все потоки данного процесса. Однако в \textit{pthreads} отсутствует стандартный способ для получения этой информации.
Для решения этой проблемы была реализована обёртка над \textit{pthreads}, которая заменяет функции создания потоков и работы с ними на следующие:
\begin{itemize}
\item \textit{thread\_create}~--- функция создания потока, в неё передаётся
точка входа~--- указатель на функцию, с которого начнёт исполнение новый поток;
\item \textit{thread\_join}~--- функция присоединения к потоку, она получает на вход идентификатор потока, завершения которого будет ждать текущий;
\item \textit{thread\_exit}~--- функция завершения исполнения текущего потока;
\item \textit{thread\_cancel}~--- функция завершения потока по его идентификатору.
\end{itemize}

Также переопределяются функции для работы с мьютексами и условными переменными.

Для корректной работы сборщика мусора клиентское приложение обязано использовать эти функции.

Для каждого из потоков создаётся дескриптор~--- структура, которая содержит
в себе целочисленный идентификатор, ссылки на необходимые для сборки мусора
структуры этого потока, точку входа и флаги состояния. Все дескрипторы работающих потоков хранятся в виде односвязного списка.

Во время этапа маркировки в алгоритме сборки мусора для построения корневого множества обходится стек вызовов, поэтому необходимо определять его вершину для каждого потока.  Для этого при создании потока в качестве точки входа в него устанавливается вспомогательная функция \textit{start\_routine}. Эта функция выполняется первой в новом потоке, поэтому адрес её кадра стека можно использовать как вершину стека для потока. Она также используется для корректной инициализации локальных для потока структур данных, так как ей доступны указатели на них. Поэтому в начале своей работы она записывает в дескриптор вершину стека и указатели на необходимые для сборщика мусора структуры. После этого она добавляет дескриптор
в список дескрипторов и запускает настоящую точку входа. После завершения основной функции, 
 \textit{start\_routine} убирает дескриптор из списка и завершает свою работу.
Также дескрипторы убираются из списка в функциях \textit{thread\_exit} и \textit{thread\_cancel}.

Одновременное изменение списка дескрипторов небезопасно и может привести к ошибкам.
Поэтому для того, чтобы получить доступ к этому списку, поток должен сначала захватить блокировку на мьютексе \textit{gc\_mutex}, что гарантирует изменение списка не более, чем одним потоком в один момент времени.

\subsubsection{Безопасные точки.}
Сборка мусора не может запускаться из произвольной точки программы. Например, если сборка мусора начнёт свою работу посредине создания объекта, то, так как на объект ещё нет ссылок, то сборщик мусора
посчитает его недостижимым и освободит память из-под него. Но после этого программа продолжит создавать этот объект и будет обращаться к освобождённой памяти, что повлечёт ошибки.

Для того чтобы избежать ошибок, в программе необходимо отметить участки кода, в которых может безопасно выполниться сборка мусора. Такие участки называются  безопасными точками. Для корректной работы приложения сборка мусора должна запускаться только тогда, когда все потоки находятся в безопасных точках.

В каждую безопасную точку вставляется код, который гарантирует, что сборка мусора будет запускаться только внутри них. Дескриптор потока содержит флаг, который указывает, что поток находится в безопасной точке.

В данной реализации сборщика мусора точка является безопасной, когда на каждый достижимый объект в куче существует управляемый указатель. То есть безопасная точка не может располагаться посредине создания нового объекта, а также между взятием сырого указателя на объект и добавлением его в хэш-таблицу разыменованых объектов.

Для того чтобы пользователю не приходилось вручную расставлять код безопасной точки, в данной реализации безопасные точки заранее расставлены внутри заранее некоторых функций библиотеки, например, внутри функции выделения памяти.


Код безопасной точки приведён в следующем разделе.

\subsubsection{Stop-the-world.} \label{ch:stop-the-world}
Если запустить сборку мусора параллельно работе программы, то это может привести к различным ошибкам, так как куча может изменится между стадией маркировки и удаления недостижимых объектов. Для решения этой проблемы существует несколько основных подходов к работе сборщика мусора в многопоточной программе.
\begin{itemize}
\item Stop-the-world сборщики мусора, во время работы которых все потоки приложения приостанавливаются. 
\item Инкрементальные сборщики мусора, в которых сборка мусора выполняется параллельно работе программы. Они используют сложные алгоритмы для синхронизации сборщика мусора и приложения, но увеличивают накладные расходы на сборку мусора.
\end{itemize}

В данной работе реализован stop-the-world сборщик мусора.

Существует несколько способов выбора потока, в котором будет выполняться сборка мусора. В данной работе используется следующая стратегия: каждый поток может заявить о том, что он будет собирать мусор в этом цикле сборки мусора. Если таких потоков несколько в один момент времени, то сборщиком будет первый заявивший. Для реализации данного поведения используется глобальная переменная \textit{gc\_thread}, в которую поток записывает свой дескриптор, если он хочет быть сборщиком  мусора. Для того чтобы в эту переменную одновременно не записали несколько потоков, для обращения к ней поток должен захватить мьютекс \textit{gc\_mutex}. 

Как отмечалось ранее, сборка мусора возможна только тогда, когда все потоки находятся в безопасных точках. Чтобы это выполнялось, каждый поток обходит список дескрипторов и для каждого из них проверяет, установлен ли флаг безопасной точки. Если это не верно, то этот поток приостанавливается, ожидая, пока кто-нибудь не сообщит о том, что он находится в безопасной точке. Данное поведение реализовано с помощью условной переменной (\textit{condition variable}) \textit{safepoint\_reached}.

Внутри безопасной точки поток проверяет, записан ли в переменную \textit{gc\_thread} дескриптор какого-нибудь потока. Если это так, то это значит, что сборщик мусора ожидает, пока какой-то поток окажется в безопасной точке. Текущий поток отправляет сигнал потоку, ожидающему условную переменную \textit{safepoint\_reached}, и приостанавливается до завершения сборки мусора. 

Итоговый код безопасной точки описан далее в алгоритме~\ref{alg:safepoint}.

\begin{algorithm}[h]
\begin{algorithmic}[1]
\State $lock(gc\_mutex)$
\State $current\_thread \gets$ дескриптор текущего потока
\State $current\_thread.safepoint \gets true$
\If{$gc\_thread \neq NULL$}
    \State $notify(safepoint\_reached)$
    \State $wait(gc\_finished)$
\EndIf
\State $current\_thread.safepoint \gets false$
\State $unlock(gc\_mutex)$
\end{algorithmic}
\caption{Безопасная точка}\label{alg:safepoint}
\end{algorithm}

Кроме этого, поток, который ждёт завершения работы другого потока или освобождения мьютекса, также находится в безопасной точке. Поэтому во всех функциях, которые блокируют поток (например, в функции \textit{thread\_join}) также выставляется флаг безопасной точки для текущего потока.

После того, как все потоки достигли безопасной точки и остановились, поток со сборщиком мусора выполняет сборку мусора. После этого он сбрасывает переменную \textit{gc\_thread} и сообщает всем потокам о завершении с помощью условной переменной \textit{gc\_finished}.

Полная реализация \textit{stop-the-world} описана в алгоритме~\ref{alg:stoptheworld}.

\begin{algorithm}[h]
\begin{algorithmic}[1]
\State $lock(gc\_mutex)$
\State $current\_thread \gets дескриптор текущего потока$ 
\State $current\_thread.safepoint \gets true$
\If{$gc\_thread = NULL$}
    \State $gc\_thread \gets current\_thread$
    \ForAll {$thread \gets threads\_list$}
        \If {$thread.safepoint = false$}
            \State $wait(safepoint\_reached)$
        \EndIf
    \EndFor
    \State $gc()$
    \State $notify(gc\_finished)$
    \State $gc\_thread \gets NULL$
\Else
    \State $notify(safepoint\_reached)$
    \State $wait(gc\_finished)$
\EndIf
\State $current\_thread.safepoint \gets false$
\State $unlock(gc\_mutex)$
\end{algorithmic}
\caption{Stop-the-world}\label{alg:stoptheworld}
\end{algorithm}
\subsection{Сжатие}
В этом разделе подробно описывается реализация используемого в данной библиотеке сжимающего алгоритма сборки мусора.
\subsubsection{Устройство кучи.}
Для того чтобы реализовать сжимающую сборку мусора, необходима реализации кучи, которая поддерживала бы перенос объектов и осуществляла его. В исходной библиотеке использовалась куча Дага Ли\footnote{http://g.oswego.edu/dl/html/malloc.html}~--- один из самых известных менеджеров динамической памяти, долгое время являющийся стандартным в некоторых сборках стандартной библиотеки языка C и операционной системы Linux. К сожалению, эта куча не поддерживает перенос данных. К тому же данная куча имеет запутанную структуру исходного кода, а также сильно оптимизирована. Поэтому в неё нелегко добавить поддержку копирования. Поэтому в данной работе была написана своя реализация кучи, которая поддерживает копирование.

В данной реализации вся память кучи поделена на страницы одинакового размера. По умолчанию страницы имеют размер, равный размеру страницы памяти в операционной системе. Страницы не обязаны находиться в одном непрерывном куске памяти, и поэтому хранятся в односвязном списке \textit{pages}. Память под страницы запрашивается у операционной системы с помощью функции \textit{mmap}. Из-за того, что \textit{mmap} является достаточно долгой операцией, и запросить один блок большого размера быстрее, чем запросить блок маленького размера, за один запрос у операционной системы получается сразу несколько страниц. Неиспользуемые страницы хранятся в односвязном списке \textit{free\_list}. Если необходимо получить новую страницу, куча сначала берет свободные страницы из \textit{free\_list}, а если он пуст, то запрашивает следующий блок у операционной системы. С целью улучшения производительности с каждым новым запросом к операционной системе количество запрашиваемой памяти увеличивается в два раза. Данный процесс описан в алгоритме~\ref{alg:newpage}.

\begin{algorithm}[h]
\begin{algorithmic}[1]
\If{$empty(free\_list)$}
    \State $new\_memory \gets mmap(PAGE\_SIZE * per\_request)$
    \State $curr \gets new\_memory$
    \While{$curr < new\_memory +$\par
        \hskip1cm $PAGE\_SIZE * per\_request$}
        \State $push(free\_list, curr)$
        \State $curr \gets curr + PAGE\_SIZE$ 
    \EndWhile
    \State $per\_request \gets per\_request * 2$
\EndIf
\State \Return $pop(free\_list)$ 
\end{algorithmic}
\caption{Запрос свободной страницы}\label{alg:newpage}
\end{algorithm}

Каждая страница состоит из заголовка и непрерывного куска памяти, который целиком делится на блоки. Каждый блок содержит свой размер и полезные данные.
Блоки делятся на два типа~--- свободные и занятые. В занятых блоках хранится информация, которая в данный момент используется приложением. В каждой странице все блоки, кроме самого последнего, обязательно являются занятыми, а последний обязательно является свободным. Поэтому при выделении памяти внутри страницы занятый блок создаётся на месте последнего свободного, а оставшаяся память становится новым свободным блоком. Для ускорения этого процесса заголовок страницы содержит указатель на свой свободный блок.

В данной куче для ускорения работы выделение памяти происходит только в последней странице. Если в последней странице не хватает места, то запрашивается новая страница и блок выделяется в ней. 

Для блоков памяти, размер которых больше, чем размер страницы, куча напрямую запрашивает память у операционной системы. Для таких объектов в куче создаётся отдельный односвязный список.
Алгоритм~\ref{alg:malloc} описывает процесс выделения памяти. 

\begin{algorithm}[h]
\begin{algorithmic}[1]
\If{$size > BIG\_BLOCK\_THRESHOLD$}
    \State $block \gets mmap(size + header\_size)$
    \State $push(big\_blocks, block)$
    \State \Return $block.data$
\EndIf
\If{$pages = NULL$}
    \State $pages \gets request\_new\_page()$
    \State $last\_page \gets pages$
\EndIf
\If {$not~last\_page.free\_block.size \geq size$}
    \State $page \gets request\_new\_page()$
    \State $last\_page.next \gets page$
    \State $last\_page \gets page$
\EndIf
\State $block \gets last\_page.free\_block$
\State $last\_page.free\_block \gets block.data + header\_size$
\State $last\_page.free\_block.size \gets block.size - size - header\_size$
\State $block.size \gets size$
\State \Return $block.data$
\end{algorithmic}
\caption{Выделение памяти}\label{alg:malloc}
\end{algorithm}

Так как данная куча используется только вместе со сборщиком мусора, то в ней нет необходимости освобождать память вне процесса сборки мусора.

\subsubsection{Закрепление объектов.}
Некоторые объекты невозможно перенести, избежав при этом ошибок в работе программы. Например, при вызове метода какого-нибудь объекта на стек записывается указатель \textit{this}, точное положение которого невозможно узнать без поддержки компилятора.

Поэтому в предложенной реализации существует возможность указать куче, что некоторый блок памяти является закреплённым~--- его нельзя переносить.
Для этого в заголовке каждого блока создаётся специальный флаг закреплённости.
Для уменьшения размера заголовка, флаг закреплённости располагается в младшем бите размера блока. Чтобы это не создавало ошибок, куча при выделении памяти для блока округляет его размер вверх до восьми. В таком случае, младшие три бита размера всегда равны нулю, и их можно использовать для расположения различных флагов.
\subsubsection{Алгоритм.}
Реализованный в библиотеке алгоритм сборки мусора состоит из нескольких этапов, самыми важными из которых являются пометка и сжатие. Далее будут подробно рассмотрены все этапы работы алгоритма.
\begin{enumerate}
\item Поток, инициирующий сборку мусора, приостанавливает приложение, как описано в разделе~\ref{ch:stop-the-world}.
\item Сборщик мусора обходит корневое множество и запускает поиск достижимых из них объектов. Достижимые объекты помечаются флагом достижимости в соответствующем блоке в куче.
\item Сборщик мусора обходит стеки вызовов всех потоков и ищет в них указатели, содержащиеся в  хэш-таблице разыменованных объектов. Если такие указатели были найдены, то объекты, на которые они указывают, помечаются флагом закреплённости.
Благодаря этому все объекты, которые нельзя переносить, не будут перенесены. Также от таких объектов выполняется поиск достижимых объектов, как на предыдущем этапе. \label{step:deref}
\item Когда все живые объекты помечены, сборщик мусора приступает к освобождению памяти. Для начала он обходит все блоки с большими объектами, находит те, у которых не выставлен ни флаг достижимости, ни флаг закреплённости и освобождает память из-под них с помощью функции \textit{munmap}.
\item Далее сборщик мусора обходит все страницы в \textit{pages} и ищет в них закреплённые блоки. Если на какой-то странице содержится хотя бы один закреплённый блок, то эта страница считается пережившей сборку мусора и переносится в список выживших страниц \textit{alive\_pages}.
\item После этого алгоритм производит сжатие. Для этого он обходит все блоки в оставшихся в \textit{pages} страницах. Если у блока выставлен флаг достижимости, то в \textit{alive\_pages} находится наименьший свободный блок, размер которого превосходит размер копируемого блока. Если такой блок не находится, то в \textit{alive\_pages} добавляется новая страница. После этого информация из старого блока копируется в новый, а в старый блок записывается указатель на новый блок. Для ускорения процесса поиска наименьшего блока сборщик мусора строит список свободных блоков каждого размера. Более подробно этот этап описан в алгоритме~\ref{alg:copy}.
\item После этого сборщик мусора исправляет указатели на перенесённые объекты. Для этого сборщик обходит корневое множество, и если объект, на который указывает корень, был перенесён, то изменяет его на указатель на новый блок. Такую же операцию сборщик мусора проделывает со всеми указателями внутри объектов в \textit{alive\_pages}.
\item Далее сборщик мусора переносит все страницы из \textit{pages} во \textit{free\_list}, заменяет \textit{pages} на \textit{alive\_pages} и устанавливает новый \textit{last\_page}.
\item Сборщик мусора обходит хэш-таблицу разыменованных указателей и удаляет оттуда те, которые не были найдены на этапе~\ref{step:deref}.
\item Последним этапом сборщик мусора сообщает всем потокам о завершении работы алгоритма. 
\end{enumerate}

\begin{algorithm}
\begin{algorithmic}[1]
\For {$i \gets 1..PAGE\_SIZE$}
    \State $clear(free[i])$
\EndFor
\For {$page \gets alive\_pages$}
    \State $push(free[page.free\_block.size], page)$
\EndFor
\For {$page \gets pages$}
    \For {$block \gets page$}
        \If{$block.marked$}
            \State $size \gets block.size$
            \State $page\_to\_copy \gets NULL$
            \For {$i \gets size..PAGE\_SIZE$} 
                \If {$not~empty(free[i])$}
                    \State $page\_to\_copy \gets pop(free[i])$
                    \State break
                \EndIf
            \EndFor
            \If{$page\_to\_copy = NULL$}
                \State $page\_to\_copy \gets request\_new\_page()$
                \State $push(alive\_pages, page\_to\_copy)$
            \EndIf
            \State $copy(block.data, page\_to\_copy.free\_block.data)$
            \State $block.data = page\_to\_copy.free\_block.data$
            \State $page\_to\_copy.free\_block \gets block.data + header\_size$
            \State $new\_size \gets block.size - size - header\_size$
            \State $page\_to\_copy.free\_block.size \gets new\_size$
            \State $push(free[new\_size], page\_to\_copy)$
        \EndIf
    \EndFor
\EndFor

\end{algorithmic}
\caption{Сжатие}\label{alg:copy}
\end{algorithm}

\section{Тестирование и апробация}
Данная реализация сборщика мусора была функционально протестирована на тестах, написанных вручную. Для проверки отсутствия регрессионных ошибок использовались существующие тесты, для проверки нового функционала были написаны новые тесты.

Также для данной реализации было произведено тестирование производительности. Сравнение проводилось с производительностью работы аналогичных тестов без использования автоматического управления памятью и с подсчётом ссылок. 

Результаты тестирования представлены ниже в таблицах.
В таблице~\ref{table:tree} находятся результаты исполнения широко используемого теста производительности Бёма\footnote{http://hboehm.info/gc/gc\_bench.html}. В данном тесте строятся двоичные деревья различной глубины с разной продолжительностью жизни, а также различным способом построения. В таблице в колонке ``raw'' указаны результаты для ручного управления памятью, в колонке ``shared''~--- подсчета ссылок, и, наконец, в ``mostly''~--- результаты данной библиотеки. Каждая из этих колонок в свою очередь делится на три области. Колонка ``top'' подказывает общее время построения деревьев сверху-вниз, ``bottom'' показывает время построения снизу-вверх, а колонка ``total'' обозначает общее время работы приложения. Каждой строке соответствует максимальный размер дерева, его значение указано в столбце ``размер''. Результаты приводятся как среднее время из 20 запусков теста, все значения указаны в миллисекундах.

Из данной таблицы видно, что обе реализации автоматического управления памятью примерно на порядок хуже реализации с ручным управлением памяти. Данная библиотека, хотя и проигрывает в скорости для небольших деревьев подсчёту ссылок, для деревьев большой глубины показывает лучшую производительность.

\begin{table}
\centering
\begin{tabular}{| c | r r r | r r r | r r r |} 
\hline
& & raw & & & shared & & & mostly & \\
\hline 
размер & top & bottom & total & top & bottom & total & top & bottom & total \\
\hline
8 & 0 & 0 & 13 & 1 & 0 & 86 & 1 & 0 & 177 \\
\hline
10 & 0 & 0 & 13 & 6 & 6 & 98 & 4 & 3 & 148 \\
\hline
12 & 2 & 2 & 15 & 35 & 32 & 141 & 22 & 61 & 216 \\ 
\hline
14 & 11 & 11 & 35 & 167 & 153 & 403 & 117 & 183 & 433 \\
\hline
16 & 57 & 54 & 127 & 822 & 777 & 1730 & 677 & 443 & 1325 \\ 
\hline
18 & 278 & 275 & 608 & 3848 & 3593 & 7813 & 3846 & 2407 & 6727 \\
\hline
\end{tabular}
\caption{Тест Бёма}
\label{table:tree}
\end{table}

В таблице~\ref{table:list} и представлен результат теста, который демонстрирует производительность работы с коллекциями. В нем создаётся список размером 100000 элементов, над которым потом производятся различные действия. Результаты также являются средними из 20 запусков, значения указаны в миллисекундах. 

Из результатов видно, что хотя в данном тесте затрачивается много времени на создание объектов, производительность библиотеки сравнима с производительностью аналогов.

\begin{table}
\centering
\begin{tabular}{| c | r | r | r |} 
\hline
& raw & shared & mostly \\
\hline
Создание & 3 & 7 & 23 \\
\hline
Инвертирование & 3 & 3 & 3 \\
\hline
Сортировка & 34 & 37 & 38 \\
\hline
Всего & 44 & 51 & 66 \\
\hline
\end{tabular}
\caption{Тест с односвязным списком}
\label{table:list}
\end{table}

Также совершенно естественным является то, что для любой реализации можно придумать тест, на котором она будет показывать плохую производительность. Например, для исследуемой библиотеки таким является тест аналогичный предыдущему, но с использованием вектора из стандартной библиотеки языка. Результаты данного теста представлены в таблице~\ref{table:vector}. 


\begin{table}
\centering
\begin{tabular}{| c | r | r | r |} 
\hline
& raw & shared & mostly \\ 
\hline
Создание & 5 & 30 & 2993 \\
\hline
Сортировка & 45 & 486 & 770 \\
\hline
Всего & 53 & 525 & 3764 \\
\hline
\end{tabular}
\caption{Тест с вектором}
\label{table:vector}
\end{table}

В этом тесте библиотека тратит много времени на построение корневого множества, так как вектор по-умолчанию размещает объекты в своей собственной области памяти. Предположительно данная проблема может быть решена с помощью введения специального менеджера памяти для коллекций стандартной библиотеки шаблонов.

\section*{Заключение}
Результатом данной работы является:

\begin{itemize}
\item исправление ошибок в работе с объектами; 
\item добавление поддержки многопоточности;
\item реализация сжимающего алгоритма сборки мусора;
\item тестирование и апробация полученой реализации.
\end{itemize}

Исходный код библиотеки распологается по адресу: \url{http://github.com/evagl/mostly-precise-gc}.

\begin{thebibliography}{99}
 \bibitem{berezun}
 D.Berezun, D.Boulytchev. Precise Garbage Collection for C++ with a Non-cooperative Compiler //
 Proceedings of the 10th Central and Eastern European Software Engineering Conference in Russia, 2014.

 \bibitem{boehm1}
 H-J.Boehm, M.Weiser. Garbage Collection in an Uncooperative Environment //
 Software: Practice and Experience, Vol.~18, \textnumero~9, 1988.

 \bibitem{boehm2}
 H-J.Boehm, A.J.Demers, S.Shenker. Mostly Parallel Garbage Collection //
 SIGPLAN Notices, Vol.~26, \textnumero~6, 1991.

 \bibitem{boehm3}
 H-J.Boehm. Space-Efficient Conservative Garbage Collection // 
 PLDI, 1993.

 \bibitem{mcc1}
 J. F. Bartlett. Mostly-Copying Garbage Collection Picks Up Generations and C++.
 Technical Report TN-12, DEC Western Research Laboratory, 1989.

 \bibitem{mcc2}
 J.F.Bartlett. Compacting Garbage Collection with Ambiguous Roots. DEC Systems Research Center,
 1988.

 \bibitem{pthreads}
 Standard for Information Technology~--- Portable Operating System Interface (POSIX). 
 System Application Program Interface (API) Amendment 2: Threads Extension (C Language).
 IEEE Std. 1003.1c-1995, 1995.

 \bibitem{lisp-copy}
 R.R.Fenichel, K.C.Yochelson.
 A LISP Garbage-Collector for Virtual-Memory Computer Systems //
 CACM, Vol.~12, \textnumero~11, 1969.

 \bibitem{lisp}
 J.McCarthy. Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I.
 1960.
\end{thebibliography}
