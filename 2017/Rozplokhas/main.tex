\title{Расширенный реляционный поиск с лучшей способностью к опровержению}
\titlerunning{Расширенный реляционный поиск}
\author{Розплохас Дмитрий Александрович}
\authorrunning{Д.А.Розплохас}
\tocauthor{Д.А.Розплохас}
\institute{Санкт-Петербургский государственный академический университет\\
\email{rozplokhas@gmail.com}}
\maketitle
  
  \begin{abstract}
    MiniKanren~--- язык, позволяющий писать программы в реляционном стиле, то есть описывать все функции как отношения. Это позволяет извлекать различные поведения из определения функции, например запускать её в обратную сторону (так, функция сортировки списка становится генератором всех перестановок заданого списка). К сожалению, из-за особенностей языка, наивно написанные программы часто не позволяют использовать эту двойственность эффективно. Для написания реляционных программ, способных на это, используются различные сложные эвристики, применение которых требует знания внутреннего устройства языка. В данной работе предлагается расширение поиска, заложенного в язык MiniKanren, делающее обращение многих простых программ эффективным. Также доказывается, что, в некотором смысле, способность к обращению гарантированно не ухудшается при расширении поиска, и приводится несколько примеров содержательных программ, исправляемых данным расширением.
  \end{abstract}
  
  \section*{Введение}
  
    Реляционное программирование~--- парадигма, в которой программа рассматривается не как функция из входных данных в выходные, а как некоторое отношение между этими данными. Благодаря этому в реляционном языке мы можем сообщить лишь часть информации о входных и выходных данных, а остальная информация будет восстановлена в процессе исполнения программы. Такой подход позволяет извлекать множество различных поведений из декларативного описания программы и, соответственно, предоставляет элегантные решения для нетривиальных задач. Например, сортировка, написанная на реляционном языке, может быть использована для генерации всех перестановок заданого списка, функция проверки типа~--- для вывода типа или перечисления обитателей типа, а интерпретатор некоторого языка~--- для синтеза программ на этом языке с определенными свойствами.

    Cпециально для программирования в этой парадигме был разработан язык MiniKanren~\cite{TRS}, ставший прародителем множества диалектов. MiniKanren позволяет описывать отношения между логическими переменными и формулировать запросы с этими отношениями, фиксируя значения некоторых переменных. Подходящие значения остальных переменных находятся поиском, лежащим в основе языка. В действительности, часто эти отношения можно задать вполне естественным путём. Рассмотрим классический пример: отношение конкатенации двух списков, написанное на одном из диалектов MiniKanren:

\begin{lstlisting}
  let rec append$^o$ a b ab =
    (a === [] /\ ab === b) \/
    (fresh (h t tb)
      (a === h :: t) /\
      (append$^o$ t b tb) /\
      (ab === h :: tb))
\end{lstlisting}

    Конкретный синтаксис будет детально рассмотрен позже, но и без его знания несложно заметить, что данное определение очень похоже на определение функции конкатенации, написанной на некотором функциональном языке с помощью сопоставления с образцом. Разбирается два случая: является первый список пустым или нет, и во втором случае определение задается рекурсивно. Но определив конкатенацию как отношение мы получаем возможность не только соединять два заданных списка (зафиксировав значения аргументов \lstinline|a| и \lstinline|b| и оставив \lstinline|ab| свободным), но и, например, найти все разбиения заданного списка на две части (зафиксировав \lstinline|ab| и оставив \lstinline|a| и \lstinline|b| свободными).

    В то же время, использование данного подхода имеет некоторые ограничения. Поиск с чередованием, лежащий в основе языка MiniKanren, гарантированно найдет каждое решение за конечное время, однако он зачастую не может определить, когда решений больше не остается, и продолжает работу бесконечно. Даже в простейшем примере использования \lstinline|append$^o$| для генерации разбиений списка программа не завершится, если не задать явно количество запрашиваемых решений и не оборвать поиск после того как они найдены. Такое поведение реляционных программ встречается повсеместно, особенно среди написанных наиболее простым способом.

    Отношение называется опровергающе полным (refutationally complete~\cite{WillThesis}), если поиск по нему всегда завершается, когда решений нет. Отношения такого типа являются предпочтительными, так как возможность не фиксировать заранее число решений может быть полезна, например, если количество всех решений сложно вычислить, или если мы хотим использовать реляционную программу для доказательства отсутствия решений. Кроме того, незавершаемость поиска зачастую является показателем неэффективного пути поиска решений, поэтому опровергающе полные отношения обычно позволяют находить решения быстрее.

    Чтобы сделать определение \lstinline|append$^o$| опровергающе полным достаточно переместить рекурсивный вызов в конец конъюнкции. К сожалению, в более сложных примерах проблема не решается простым изменением порядка. В настоящее время содержательные программы на MiniKanren пишутся с использованием сложных эвристик, реализация (и даже понимание) которых требует значительных усилий и значительного понимания внутреннего устройства языка, что в некотором роде противоречит его декларативной природе.

    Мотивация данной работы~--- позволить программисту писать простые опровергающе полные отношения, для чего предлагается изменение заложенного в язык поиска. Хотя в общем случае задача сделать отношение опровергающе полным неразрешима (так, не существует опровергающе полных интерпретаторов для Тьюринг-полных языков: с их помощью очевидно решалась бы проблема останова), она может быть решена единым способом для ряда важных программ.

  \section{Постановка задачи}
  
    Целью данной работы является расширение алгоритма поиска в языке MiniKanren, благодаря которому большее число програм стало бы опровергающе полными. Более конкретно, мы хотим предложить подход, изменяющий стратегию поиска решения, основываясь на определенном критерии незавершаемости программ.

    Для достижения этой цели были поставлены следующие задачи:
  
    \begin{itemize}
      \item сформулировать критерий незавершаемости реляционных программ и сконструировать расширенный алгоритм поиска на его основе;
      \item доказать корректность предложенного критерия;
      \item реализовать расширенный алгоритм и апробировать его на ряде содержательных примеров отношений.
    \end{itemize}
  
  \section{Обзор}
  
    Язык MiniKanren разрабатывался как минималистичный, декларативный и чистый (без побочных эффектов) логический язык, основанный на идее поиска с чередованием~\cite{Interleaving}. Он является встраиваемым предметно-ориентированным языком (изначально для Scheme), что позволяет изолированно использовать реляционный подход в программах на других языках. Простота внутреннего устройства языка также даёт возможность удобно реализовывать различные расширения, такие как инструменты для программирования в ограничениях (constraint programming)~\cite{CKanren} и номинального логического программирования (nominal logic programming)~\cite{alphaKanren}.

    На данный момент MiniKanren применяется главным образом для реализации и использования реляционных интерпретаторов. Эта техника позволяет генерировать программы со сложным поведением, такие как ``квайны''~\cite{Untagged}, а также генерировать программы по наборам тестов~\cite{unified}. В то же время, для приемлемой эффективности эти программы требуют ряда эвристических оптимизаций, отличающихся в каждом конкретном случае, поэтому для их реализации нужны значительные усилия. Характерным примером явлется контраст~\cite{WillThesis} между наивной реализацией отношений двоичной арифметики и изобретательной, но неинтуитивной реализацией её опровергающе полной версии~\cite{KiselyovArithmetic}. Этот пример будет рассмотрен подробнее в разделе 5.

    На сегодняшний день существует более 30 версий MiniKanren для разных внешних языков~\cite{MiniKanrenOrg}. В качестве базы данного исследования мы используем OCanren~\cite{ocanren}~--- типизированное встраивание MiniKanren в язык OCaml.
    
  \subsection{Описание языка}
    
    Базовыми элементами синтаксиса являются идентификаторы (для них будут использоваться обозначения $x$, $x_1$, $x_2$, $\dots$) и термы (для них будут использоваться обозначения $t$, $t_1$, $t_2$, $\dots$). Термы создаются с помощью конструкторов произвольной арности (возможно, арности 0~--- констант), определенных во внешнем языке, которые применяются к идентификаторам или другим термам. Например, \lstinline|[]| и \lstinline|1 :: (2 :: [])| являются термами, не содержащими идентификаторов, а \lstinline|hd :: []|~--- терм с идентификатором.
    
    Отношения в языке задаются целями (goals, для них будут использоваться обозначения $g$, $g_1$, $g_2$, $\dots$), которые в наиболее простой версии OCanren могут быть сконструированны c помощью четырех примитивов: унификации двух термов (\mbox{$t_1 \equiv t_2$}), конъюнкции целей (\mbox{$g_1 \wedge g_2$}), дизъюнкции целей (\mbox{$g_1 \vee g_2$}) и введения ``свежей'' логической переменной (\lstinline|fresh ($x$) $g$|). Также могут использоваться вызовы функций-отношений (в том числе рекурсивные) с помощью внешнего языка (\lstinline|$r^k$ $t_1$ $\dots$ $t_k$| для вызова отношения с именем $r^k$ арности $k$).
    
    В программе описывается информация о связи между логическими переменными (для них будут использоваться обозначения $\alpha$, $\alpha_1$, $\alpha_2$, $\dots$), которая выражается в виде подстановок (для них будут использоваться обозначения $\sigma$, $\sigma_1$, $\sigma_2$, $\dots$), унифицирующих термы~\cite{Unification}. Мы будем использовать их здесь не определяя, сохраняя обозначения, используемые в статье. Мы также будем обозначать через $mgu\,(t_1, t_2)$ наиболее общий унификатор для двух темов $t_1$ и $t_2$, вычисляемый простейшим алгоритмом унификации, представленным в статье.
    
    Чтобы описать алгоритм исполнения реляционных программ, мы выпишем операционную семантику большого шага для языка OCanren. А именно, опишем отношение \mbox{$\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S}$}, где $\Gamma$~--- множество определенных в программе отношений (задается отображением из имени отношения в определение), $\iota$~--- интерпретация идентификаторов (также являющаяся подстановкой), состояние задается парой из $\sigma$~--- подстановки и $\delta$~--- множества логических переменных,  известных на данный момент, и наконец $S$~--- конечное мультимножество состояний, являющееся результатом исполнения отношения $g$ с начальным состоянием $(\sigma, \delta)$ в данном окружении. Данная семантика описывает только исполнение отношений, поиск по которым конечен. Нам потребуется формальное описание только для таких отношений, поведение программ с бесконечным поиском можно понять по аналогии: поиск производится в бесконечном дереве, построенном по тем же правилам, решения возвращаются по мере нахождения, что позволяет оборвать поиск и получить конечное подмножество решений.
    
    \begin{figure}
    
       \[ \searchRule{\Gamma}{\iota}{\sigma}{\delta}{t_1 \equiv t_2}{\emptyset}, \quad mgu(t_1 \iota \sigma, t_2 \iota \sigma) = \bot
           \ruleno{UnifyFail} \]
       
       \[ \searchRule{\Gamma}{\iota}{\sigma}{\delta}{t_1 \equiv t_2}{(\sigma \Delta, \delta)}, \quad mgu(t_1 \iota \sigma, t_2 \iota \sigma) = \Delta \ne \bot
           \ruleno{UnifySuccess} \]
       
       \[ \frac{ \begin{array}{c}
                       \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g_1}{S_1} \\
                       \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g_2}{S_2}
                     \end{array} }
                  {  \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g_1 \vee g_2}{S_1 \uplus S_2}}
           \ruleno{Disj} \]
         
       \[ \frac{ \begin{array}{c}
                       \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g_1}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } \\
                       \searchRule{\Gamma}{\iota}{\sigma_i}{\delta_i}{g_2}{S_i}
                     \end{array} }
                  {  \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g_1 \wedge g_2}{\uplus_i S_i}}
           \ruleno{Conj}  \]
           
        \[ \frac{ \searchRule{\Gamma}{\iota[x \leftarrow \alpha]}{\sigma}{\delta \cup \alpha}{g}{ S } }
               { \searchRule{\Gamma}{\iota}{\sigma}{\delta}{\lstinline|fresh ($x$) \ $g$|}{S}},
                 \alpha \not\in \delta
            \ruleno{Fresh} \]
        
        \[ \frac{ \searchRule{\Gamma}{\epsilon[x_1 \leftarrow v_1, \dots, x_k \leftarrow v_k]}{\epsilon}{\delta}{g}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } }
                   { \searchRule{\Gamma}{\iota}{\sigma}{\delta}{\lstinline|$r^k$ $t_1$ $\dots$ $t_k$|}{ \{ (\sigma \sigma_1, \delta_1), \dots, (\sigma \sigma_n, \delta_n) \} }}, 
             \ruleno{Invoke} \]
        \[             v_i = t_i \iota \sigma, \quad \Gamma(r^k) = \lambda x_1 \dots x_k. g  \]
           
       \caption{Семантика языка OCanren}
    
    \end{figure}
    
   %  \[ \searchRule{\Gamma}{\iota}{\sigma}{\delta}{t_1 \equiv t_2}{\emptyset}, \quad mgu(t_1 \iota \sigma, t_2 \iota \sigma) = \bot \]
    
    При выполнении унификации к термам сначала применяется интерпретация (каждый идентификатор в терме заменяется на соответствующее значение), а затем текущая подстановка. Программа корректна, лишь когда для каждого идентификатора интерпретация определена на нём в момент его вычисления. Для полученых термов вычисляется наиболее общий унификатор, и, если его не существует (термы невозможно унифицировать), то результатом является пустое мультимножество, так как решений нет (правило \textsc{UnifyFail}). Если наиболее общий унификатор существует, подстановка в состоянии превращается в композицию изначальной подстановки с ним~--- добавляется информация полученная при унификации (правило \textsc{UnifySuccess}).
    
    При исполнении дизъюнкции двух целей их результаты объединяются (правило \textsc{Disj}). При исполнении конъюнкции двух целей к результатам исполнения первой применяется вторая (информация из второй добаляется к иноформации, полученной из первой), после чего все результаты объединяются (правило \textsc{Conj}).
    
    %\[ \frac{ \searchRule{\Gamma}{\iota[x \leftarrow \alpha]}{\sigma}{\delta \cup \alpha}{g}{ S } }
    %           { \searchRule{\Gamma}{\iota}{\sigma}{\delta}{\lstinline|fresh ($x$) \ $g$|}{S}},
    %             \alpha \not\in \delta \]
                 
    Оператор \lstinline|fresh| связывает с идентификаторам логическую переменную, ранее не использовавшуюся (правило \textsc{Fresh}).
    
    %\[ \frac{ \searchRule{\Gamma}{\epsilon[x_1 \leftarrow v_1, \dots, x_k \leftarrow v_k]}{\epsilon}{\delta}{g}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } }
    %           { \searchRule{\Gamma}{\iota}{\sigma}{\delta}{\lstinline|$r^k$ $t_1$ $\dots$ $t_k$|}{ \{ (\sigma \sigma_1, \delta_1), \dots, (\sigma \sigma_n, \delta_n) \} }}, \]
    %\[             v_i = t_i \iota \sigma, \quad \Gamma(r^k) = \lambda x_1 \dots x_k. g \]

    При вызове отношения с именами аргументов $x_1$, $\dots$, $x_k$ и телом $g$, с именами аргументов связываются значения соответствующих термов с начальной подстановкой, после чего тело выполняется с пустой начальной подстановкой (обозначена здесь $\epsilon$), все результаты совмещаются с начальной подстановкой (правило \textsc{Invoke}).
    
    Используя данный алгоритм исполнения программ, мы можем восстанавливать часть информации об аргументах отношения, заменив в изначальной интерпретации их значения логическими переменными и рассмотрев значения этих переменных в подстановках-результатах. Если эти значения будут в свою очередь также содержать логические переменные, данный результат будет кодировать целое множество возможных решений, в которых вместо каждой логической переменной подставлены всевозможные значения подходящего типа. Например, для отношения \lstinline|append$^o$| с фиксированным первым аргументом в семантике выводимо следующее утверждение:  

\[ 
\begin{array}{c}
\Gamma,\,[b \leftarrow \alpha, ab \leftarrow \alpha']\vdash (\epsilon,\,\{\alpha, \alpha'\})\\
\xRightarrow{\lstinline|append$^o$| \; (1 :: 2 :: []) \; b \; ab}\\
\{([\alpha' \leftarrow 1 :: 2 :: \alpha], \{\alpha, \alpha'\})\}
\end{array}
\]

    То есть корректным решением будет любой список в качестве второго аргумета, и этот же список с элементами $1$, $2$, добавленными в начало, в качестве третьего.
    
  \subsection{Описание проблемы}
  
    Важная особенность алгоритма исполнения реляционных программ состоит в том, что при вычислении дизъюнкции поиск в двух ветках производится параллельно (это позволяет найти каждый ответ через конечное время), а при вычислении конъюнкции он производится последовательно (невозможно запустить поиск во второй ветке, не получив решения из первой). Последнее приводит к зависимости поведения программы от порядка, в котором записаны конъюнкты. Например, если поиск в первом конъюнкте не завершается, он не завершится и во всей конъюнкции, даже если поиск во втором конъюнкте (как и поиск при обратном порядке) немедленно завершается без решений.
    
    Данный эффект является распространенной причиной незавершаемости и, соответственно, опровергающей неполноты наивных программ. В частности, из-за него не завершается поиск всех разбиений списка с помощью наивной версии \lstinline|append$^o$|: когда происходит рекурсивный вызов, мы не знаем значение  \lstinline|tb| (информация о нем содержится в следующем конъюнкте), как и значение двух других аргументов, поэтому в рекурсивном вызове происходит бесконечное перечисление всех пар списков вместе с их конкатенацией. Хотя для \lstinline|append$^o$| можно выбрать порядок, при котором поиск всегда будет завершаться при отсутствие решений, в более сложных случаях этот порядок может быть разным для разных запросов (разной информации, сообщенной изначально), и написать опровергающе полное определение таким способом невозможно. Наш подход будет сосредоточен на борьбе именно с этим эффектом.
    
    На данный момент неизвестно, возможно ли эффективно реализовать поиск для конъюнкции таким образом, чтобы сделать её коммутативной. Существует очевидный способ: испытать все порядки и завершить исполнение, как только поиск с одним из из них завершится, однако из-за экспоненциального числа вариантов в худшем случае этот способ непрактичен для всех программ, кроме простейших. Возможно, коммутативность конъюнкции можно симулировать, совместив несколько нетривиальных расширений языка~\cite{WillThesis}, но конкретный способ и его эффективность пока не известны. Мы используем альтернативный подход, не изменяющий способ поиска для конъюнкции, а изменяющий порядок конъюнктов в процессе исполнения программы.
    
  \section{Расширение поиска}
    
    Предлагаемое нами расширение также заключается в перезапусках поиска с различными порядками конъюнктов. Однако теперь перезапуск будет происходить только при необходимости, когда расходимость поиска с текущим порядком неизбежна. Для определения этой необходимости мы предлагаем конкретный критерий незавершаемости реляционных программ.
    
  \subsection{Критерий незавершаемости}
  
    Критерий формулируется так: если при исполнении вызова некоторого отношения со значениями аргументов $a_1, \cdots, a_k$ происходит рекурсивный вызов этого отношения со значениями аргументов $b_1, \cdots, b_k$, которые являются более общими (существует подстановка $\tau$, такая, что $\forall i\;b_i \tau = a_i$), то исполнение этой программы никогда не завершится. Например, вызов отношения \lstinline|append$^o$| с фиксированным значением аргумента \lstinline|ab| и свободными остальными удовлетворяет этому критерию: происходит рекурсивный вызов с тремя разными логическими переменными в качестве аргументов, которые могут быть приведены подстановкой к любому другому набору аргументов.
    
    Интуитивно, такая ситуация гарантированно приводит к расходимости, потому что если во внешнем вызове исполнение дошло до рекурсивного вызова, не встретив противоречия, то это произойдет и в рекурсивном вызове, которому сообщено не больше информации, поэтому произойдет рекурсивный вызов внутри рекурсивного вызова и так далее, цикл никогда не будет прерван. Формальное доказательство этих соображений приведено в разделе 4.
    
    Корректность критерия, которая будет доказана, состоит в его односторонней ошибке: если критерий выполнен, то программа гарантированно не завершится, но если он не выполнен, мы ничего не можем сказать о завершаемости программы. В действительности, если мы возьмем любое отношение и добавим к нему дополнительный аргумент~--- счетчик вызовов~--- то при исполнении этого отношения критерий никогда не будет выполнен (дополнительный аргумент всегда будет менее общим), независимо от реального поведения программы. Однако, как показывает практика, критерий позволяет обнаружить расходимость для всех естественных отношений.
    
  \subsection{Изменение порядка}  
  
    Простейшим способом реализации изложенной идеи было бы при срабатывании критерия откатиться до ближайшей конъюнкции, у которой мы обнаружили расходимость в первой ветке, и поменять местами её конъюнкты. Такой способ сработает, например, для \lstinline|append$^o$|: первым же изменением мы переместим рекурсивный вызов в конец и получим опровергающе полное отношение. Однако для более содержательных программ этот способ будет работать недостаточно успешно по нескольким причинам.
  
    Во-первых, если после изменения в первой ветке снова обнаружится расходимость, порядок изменится на изначальный и мы попадем в бесконечный цикл перехода между этими двумя порядками. При этом возможно, что информация, достаточная для завершения, может быть получена изменением порядка в одной из более ранних конъюнкций. Например, если причиной незавершаемости является неправильный порядок в некотором отношении, но расходимость обнаруживается только в другом, которое им вызывается. Чтобы избежать этого, необходимо каким-то образом хранить информацию об уже сделанных изменениях и не повторять их.
  
    Во-вторых, если мы изменяем порядок, только меняя местами конъюнкты конъюнкции из двух элементов, мы сможем получить только небольшую долю порядков для длинных конъюнкций. Например в конъюнкции $g_1 \wedge (g_2 \wedge g_3)$ мы никогда не сможем получить порядок $g_2 \wedge g_1 \wedge g_3$, и поэтому не сможем исправить отношение, если это единственный порядок, который приводит к завершаемости. Поэтому нужны более сложные изменения. Для простоты будем считать, что конъюнкции более чем из двух элементов всегда ассоциированны вправо, то есть любая цель представляется в виде $g_1 \wedge (g_2 \wedge ( \dots \wedge g_k) \dots ))$ для некоторого $k \ge 1$, где все $g_i$ не являются конъюнкциями (привести программу к такому виду очень просто).
  
    Расширенный поиск, удовлетворяющий указанным требованиям, снова опишем с помощью операционной семантики большого шага. Отношение $\extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g}{r}$ будет сходно с отношением, описанным для обычного поиска, но в контекст добавится два элемента: $h$~--- значения аргументов при предыдущем вызове каждой функции (отображение из имени функции-отношения в набор логических термов) для проверки выполнимости критерия и $p$~--- дополнительная информация, необходимая при вычислении конъюнкции с измененным порядком (натуральное число, при исполнении всех целей, кроме конъюнкции, его значение будет равно нулю и будет игнорироваться), кроме того результатом в новом отношении может быть либо мультимножество подстановок, как в обычном поиске, либо сигнал о том, что исполнение данной цели не завершится при любых порядках конъюнкций, встречающихся в нём (он будет обозначаться $\bot$).
    
    \begin{figure}
    
      \[ \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{r^k t_1 \dots t_k}{ \bot }, \quad \overline{t_i \iota \sigma}\succeq h(r^k)
          \ruleno{ExtInvokeFail} \]
          
      \[ \frac{ \extSearchRule{\Gamma}{[x_i \leftarrow v_i]}{h[r^k \gets\overline{v_1}]}{0}{\epsilon}{\delta}{g}{ \{(\sigma_i, \delta_i)\} } }
               { \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{r^k t_1 \dots t_k}{ \{ (\sigma \sigma_i, \delta_i)\} }},  \]
      \[           \Gamma(r^k) = \lambda\overline{x_i}. g, \quad \overline{t_i \iota \sigma}\nsucceq h(r^k) 
         \ruleno{ExtInvokeSuccess}\]
    
      \caption{Семантика расширенного поиска: вызов отношения}
    \end{figure}
    
    Вызов отношения теперь описывается двумя правилами. Выполняется проверка критерия; здесь отношение ``более общий набор термов'' обозначается символом $\succeq$: 

$$
(b_1, \dots, b_k) \succeq (a_1, \dots, a_k) \xLeftrightarrow{def} \exists \tau \; \forall i \quad b_i \tau = a_i
$$
\noindent и в зависимости от результата либо исполнение прерывается с сигналом о расходимости (правило \textsc{ExtInvokeFail}), либо вызов происходит 
как раньше (правило \textsc{ExtInvokeSuccess}).
    
   
    % \[ \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{r^k t_1 \dots t_k}{ \bot },  \quad v_i = t_i \iota \sigma, \quad (v_1, \dots, v_k) \succeq h(r^k)
     %     \ruleno{ExtInvokeFail} \]
    
   
     % \[ \frac{ \extSearchRule{\Gamma}{\epsilon[x_1 \leftarrow v_1, \dots, x_k \leftarrow v_k]}{h[r^k \leftarrow (v_1, \dots, v_k)]}{0}{\epsilon}{\delta}{g}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } }
    %           { \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{r^k t_1 \dots t_k}{ \{ (\sigma \sigma_1, \delta_1), \dots, (\sigma \sigma_n, \delta_n) \} }}, \]
     % \[            v_i = t_i \iota \sigma, \quad \Gamma(r^k) = \lambda x_1 \dots x_k. g, \quad (v_1, \dots, v_k) \nsucceq h(r^k) \]
      
      Остальные правила переходят в новую семантику в том же виде, добавляются только дополнительные элементы контекста: $h$ передаётся дальше неизменным, а $p$ устанавливается в $0$. % Например, правило для конъюнкции в расширенном поиске будет выглядеть следующим образом:
      
      \begin{figure}
    
       \[ \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{t_1 \equiv t_2}{\emptyset}, \quad mgu(t_1 \iota \sigma, t_2 \iota \sigma) = \bot
           \ruleno{ExtUnifyFail} \]
       
       \[ \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{t_1 \equiv t_2}{(\sigma \Delta, \delta)}, \quad mgu(t_1 \iota \sigma, t_2 \iota \sigma) = \Delta \ne \bot
           \ruleno{ExtUnifySuccess} \]
       
       \[ \frac{ \begin{array}{c}
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{S_1} \\
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_2}{S_2}
                     \end{array} }
                  {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \vee g_2}{S_1 \uplus S_2}}
           \ruleno{ExtDisj} \]
         
       \[ \frac{ \begin{array}{c}
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } \\
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma_i}{\delta_i}{g_2}{S_i}
                     \end{array} }
                  {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{\uplus_i S_i}}
           \ruleno{ExtConj}  \]
           
        \[ \frac{ \extSearchRule{\Gamma}{\iota[x \leftarrow \alpha]}{h}{0}{\sigma}{\delta \cup \alpha}{g}{ S } }
               { \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{\lstinline|fresh ($x$) \ $g$|}{S}},
                 \alpha \not\in \delta
            \ruleno{ExtFresh} \]
           
       \caption{Семантика расширенного поиска: правила нормального исполнения}
    
    \end{figure}
    
    %\[ \frac{ \begin{array}{c}
    %                \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } \\
    %                \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma_i}{\delta_i}{g_2}{S_i}
    %              \end{array} }
    %            {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{\uplus_i S_i}} \]
      
    Помимо этого, добавятся правила, передающие сигнал расходимости выше (кроме случая, когда он был получен при исполнении первого элемента конъюнкции~--- этот случай будет рассмотрен отдельно). % Например, так будет выглядеть одно из двух правил передачи наверх для дизъюнкции:
    
    % \[ \frac{ \begin{array}{c}
    %                \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_2}{\bot}
    %              \end{array} }
    %            {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \vee g_2}{\bot}} \]
          
    %А так правило для конъюнкции, при обнаружении расходимости во втором конъюнкте:
    
    %\[ \frac{ \begin{array}{c}
    %                \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } \\
    %                \exists i: \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma_i}{\delta_i}{g_2}{\bot}
    %              \end{array} }
    %            {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{\bot}} \]
    
     \begin{figure}
    
       \[ \frac{ \begin{array}{c}
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{\bot}
                     \end{array} }
                  {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \vee g_2}{\bot}}
           \ruleno{DivDisjLeft} \]
        
        \[ \frac{ \begin{array}{c}
                       \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_2}{\bot}
                     \end{array} }
                  {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \vee g_2}{\bot}}
           \ruleno{DivDisjRight} \]
         
       \[ \frac{ \begin{array}{c}
                     \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \{(\sigma_1, \delta_1), \dots, (\sigma_n, \delta_n)\} } \\
                     \exists i: \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma_i}{\delta_i}{g_2}{\bot}
                     \end{array} }
                  {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{\bot}} 
           \ruleno{DivConjRight} \]
           
        \[ \frac{ \extSearchRule{\Gamma}{\iota[x \leftarrow \alpha]}{h}{0}{\sigma}{\delta \cup \alpha}{g}{ \bot } }
               { \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{\lstinline|fresh ($x$) \ $g$|}{\bot}},
                 \alpha \not\in \delta
            \ruleno{DivFresh} \]
        
        \[ \frac{ \extSearchRule{\Gamma}{[x_i \leftarrow v_i]}{h[r^k \leftarrow \overline{v_i}]}{0}{\epsilon}{\delta}{g}{ \bot } }
               { \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{r^k t_1 \dots t_k}{ \bot }},  \]
      \[            \Gamma(r^k) = \lambda \overline{x_i}. g, \quad \overline{ t_i \iota \sigma} \nsucceq h(r^k) 
         \ruleno{DivInvoke}\]
           
       \caption{Семантика расширенного поиска: распространение сигнала расходимости}
    
    \end{figure}
  
    Осталось описать изменение порядка, когда расходимость обнаруживается в первом конъюнкте. Для некоторой конъюнкции $g_1 \wedge (g_2 \wedge ( \dots \wedge g_k) \dots ))$, если при исполнении $g_1$ обнаруживается расходимость, мы будем ставить перед ним остальные конъюнкты поочередно, пока расходимость не перестанет обнаруживаться (в лучшем случае~--- из-за того, что исполнение этого конъюнкта станет завершающимся) или пока конъюнкты не закончатся. Для сохранения информации о том, какой конъюнкт сейчас является кандидатом на место первого, мы и будем использовать дополнительное число в контексте. Мы вкладываем в него следующий смысл: когда конъюнкция выполняется с некоторым $p$, это означает, что мы испытали уже $p$ кандидатов на место первого конъюнкта и эта конъюнкция по сравнению с изначальной выглядит так: $g_{p+1} \wedge (g_1 \wedge (g_2 \wedge (\dots \wedge (g_{p} \wedge (g_{p+2} \wedge (\dots \wedge g_k) \ldots ))) \ldots )))$. Для $p = 0$ это будет изначальный порядок. Если при таком порядке мы обнаружим расходимость в первом конъюнкте, следующим мы будем пробовать порядок $g_{p+2} \wedge (g_1 \wedge (g_2 \wedge (\dots \wedge (g_{p+1} \wedge (g_{p+3} \wedge (\dots \wedge g_k) \ldots ))) \ldots )))$ (правило \textsc{Reorder}). Если же $g_{p+1}$ был последним конъюнктом, то какой бы конъюнкт мы не поставили первым, исполнение конъюнкции не будет завершаться, поэтому сигнал расходимости можно передавать дальше (правило \textsc{DivConjRight}).  Для описания этих правил мы будем использовать функцию $move(p, g)$, возвращающую конъюнкцию $g$, в которой поменены местами конъюнкты с номерами $1$ и $p + 2$ (и возвращающую $\bot$, если конъюнктов меньше $p + 2$).
    
    \begin{figure}
    
       \[ \frac{ \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \bot } }
             {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{\bot} },
        \quad move(p, g_1 \wedge g_2) = \bot 
        \ruleno{DivConjRight} \]
                
    \[ \frac{ \begin{array}{c}
                    \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g_1}{ \bot } \\
                    \extSearchRule{\Gamma}{\iota}{h}{p + 1}{\sigma}{\delta}{g'}{r}
                  \end{array} }
                {  \extSearchRule{\Gamma}{\iota}{h}{p}{\sigma}{\delta}{g_1 \wedge g_2}{r}},
        \quad move(p, g_1 \wedge g_2) = g' \ne \bot
        \ruleno{Reorder} \]
           
       \caption{Семантика расширенного поиска: изменение порядка конъюнктов}
    
    \end{figure}
    
    
    %Назовем функцию которая создает цель с таким порядком конъюнктов $move(p, g_{p+1} \wedge (\dots))$. Если же $g_{p+1}$ был последним конъюнктом (в этом случае будем %считать $move(p, g_{p+1} \wedge (\dots)) = \bot$), то какой бы конъюнкт мы не поставили первым, исполнение конъюнкции не будет завершаться, поэтому сигнал расходимости %можно передавать дальше (правило \textsc{ExtInvokeSuccess}). 

    Стоит заметить, что для конъюнкции из $n$ элементов мы перебираем в худшем случае всего $\mathcal{O}(n^2)$ порядков, но гарантируем, что среди перебираемых будет порядок, дающий завершаемость, если такие вообще есть. Это сокращение происходит за счет того, что мы не меняем позицию конъюнкта на первом месте, если в нем не обнаруживается расходимость. И это обоснованно, так как любой другой завершающийся порядок останется завершающимся, если вынести этот конъюнкт в самое начало: сам он завершается, а остальные получают не меньше информации, чем раньше.

  \section{Доказательство корректности критерия}
  
    В данном разделе будут доказаны корректность предложенного критерия незавершаемости программ и следствие из неё~--- сохранение опровергающей полноты программы при переходе от стандартного поиска к расширенному.
    
    В начале докажем лемму, описывающую некоторые естественные свойства решений, получаемых поиском.
    
    \begin{lemma}$ $\par\nobreak\ignorespaces
      Для любых $\Gamma$, $\iota$, $\sigma$, $\delta$, $g$, и $S$, если 

      \[\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S},\] 

      то для любого $(\sigma_s, \delta_s) \in S$ существуют подстановка $\Delta_{\sigma}$ и множество логических переменных $\Delta_{\delta}$, такие что выполенены следующие условия:
      \begin{enumerate}
        \item $\sigma_s = \sigma \Delta_{\sigma}$
        \item $\delta_s = \delta \cup \Delta_{\delta}$
        \item $(\mathcal{D}om(\Delta_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma})) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$, где $\mathcal{D}om(\sigma)$~--- область определения подстановки, а $\mathcal{VR}an(\sigma)$~--- множество логических переменных, встречающихся в термах из множества значений подстановки $\sigma$.
      \end{enumerate}
    \end{lemma}
    \begin{proof}$ $\par\nobreak\ignorespaces
      Условие 3 означает, что дополнительная информация (подстановка) не связывает значения логических переменных, использовавшихся ранее, но в данный момент не встречающихся в значениях идентификаторов.
      
      Докажем индукцией по дереву вывода семантического отношения.
      
      Случай безуспешной унификации очевиден, так как множество результатов пусто.
      
      В случае успешной унификации подстановкой $\Delta_{\sigma}$ является вычисленный наиболее общий унификатор $mgu(t_1 \iota \sigma, t_2 \iota \sigma)$, множество известных логических переменных не меняется ($\Delta_{\delta} = \emptyset$). Условие 3 при этом выполнено потому, что используемый в языке алгоритм унификации связывает только значения логических переменных, встречающихся в термах, а значит $(\mathcal{D}om(\Delta_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma})) \subset \mathcal{VR}an(\iota \sigma)$.
      
      В случае конъюнкции из индукционных предположений следует, что для любого решения существуют подстановки $\Delta_{\sigma}$, $\Delta'_{\sigma}$ и множества логических переменных $\Delta_{\delta}, \Delta'_{\delta}$, для которых оно представляется в виде $(\sigma \Delta_{\sigma} \Delta'_{\sigma}, \delta \cup \Delta_{\delta} \cup \Delta'_{\delta})$, и при этом $(\mathcal{D}om(\Delta_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma})) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$ и $(\mathcal{D}om(\Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta'_{\sigma})) \cap ((\delta \cup \Delta_{\delta}) \setminus \mathcal{VR}an(\iota \sigma \Delta_{\sigma})) = \emptyset$. Остается доказать, что $(\mathcal{D}om(\Delta_{\sigma} \Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma} \Delta'_{\sigma})) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$. Из того, что $\mathcal{VR}an(\iota \sigma \Delta_{\sigma}) \subset \mathcal{VR}an(\iota \sigma) \cup \mathcal{VR}an(\Delta_{\sigma})$ (по определению композиции подстановок), и того, что $\mathcal{VR}an(\Delta_{\sigma}) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$, следует, что подстановка $\Delta'_{\sigma}$ не связывает логические переменные не только из $((\delta \cup \Delta_{\delta}) \setminus \mathcal{VR}an(\iota \sigma \Delta_{\sigma}))$, но и из нужного нам множества, то есть $(\mathcal{D}om(\Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta'_{\sigma})) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$. Значит $(\mathcal{D}om(\Delta'_{\sigma}) \cup \mathcal{D}om(\Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma}) \cup \mathcal{VR}an(\Delta'_{\sigma})) \cap (\delta \setminus \mathcal{VR}an(\iota \sigma)) = \emptyset$, из чего следует доказываемое утверждение, так как $\mathcal{D}om(\Delta_{\sigma} \Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma} \Delta'_{\sigma}) \subset \mathcal{D}om(\Delta_{\sigma}) \cup \mathcal{D}om(\Delta'_{\sigma}) \cup \mathcal{VR}an(\Delta_{\sigma}) \cup \mathcal{VR}an(\Delta'_{\sigma})$.
      
      В остальных случаях утверждение просто следует из индукционных предположений (в предположениях множества $\mathcal{VR}an(\iota \sigma)$ либо уменьшаются, либо в них добавляются свежие переменные, которые по определению не лежат в $\delta$).
      
    \end{proof}
  
    Следующая лемма формализует рассуждения о том, что если цепочка унификаций выполняется при некотором начальном состоянии, то она выполнится и при состоянии с меньшим количеством информации.
    
    \begin{lemma}$ $\par\nobreak\ignorespaces
    	  Для любых $\Gamma$, $\iota$, $\iota'$, $\sigma$, $\sigma'$, $\delta$, $\delta'$, $g$, $S$, и $S'$, таких что $\mathcal{D}om(\sigma) \subset \delta$, $\mathcal{D}om(\sigma') \subset \delta'$, $\mathcal{VR}an(\iota \sigma) \subset \delta$ и  $\mathcal{VR}an(\iota' \sigma') \subset \delta'$, если существует дерево вывода для утверждения
    		
    	  \[\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S}\]
    		
    	  и дерево вывода для утверждения
    		
    	  \[\searchRule{\Gamma}{\iota'}{\sigma'}{\delta'}{g}{S'},\]
    		
    	  и при этом существует подстановка $\tau$, такая что $\iota' \sigma' = \iota \sigma \tau$, то выполнены следующие условия:
    		
    	  \begin{enumerate}
        \item Для любого решения $(\sigma'_s, \delta'_s)$ из $S'$ существует решение $(\sigma_s, \delta_s)$ из $S$ и подстановка $\tau_s$, такие что $\iota' \sigma'_s = \iota \sigma_s \tau_s$.
        \item Дерево вывода первого утверждения имеет большую или равную высоту.
      \end{enumerate}
    \end{lemma}
    \begin{proof}$ $\par\nobreak\ignorespaces
      Вообще, предполагается, что $\delta$ содержит все логические переменные, известные на данный момент, поэтому все логические переменные, которые хоть как-то встречаются в известных подстановках, должны лежать в этом множестве. Однако, для доказательства данной леммы достаточно двух включений, которые требуются от $\delta$ (и двух аналогичных для $\delta'$), и мы ограничимся ими.
      
      Докажем индукцией по дереву вывода второго утверждения (с менее общим начальным состоянием).
      
      Случай безуспешной унификации очевиден, так как множество решений пусто, а дерево вывода второго утверждения имеет высоту 0.
      
      В случае, когда существует $mgu(t_1 \iota' \sigma', t_2 \iota' \sigma')$, логические термы $t_1 \iota \sigma$ и $t_2 \iota \sigma$ также могут быть унифицированы подстановкой $\tau mgu(t_1 \iota' \sigma', t_2 \iota' \sigma')$. Значит существует наиболее общий унификатор для этих двух термов $mgu(t_1 \iota \sigma, t_2 \iota \sigma)$, более общий, чем эта подстановка, то есть существует подстановка $\tau_s$, для которой $\tau mgu(t_1 \iota' \sigma', t_2 \iota' \sigma') = mgu(t_1 \iota \sigma, t_2 \iota \sigma) \tau_s$. Эта подстановка подходит под условие 1, так как $\iota' \sigma' mgu(t_1 \iota' \ \sigma', t_2 \iota' \sigma') = \iota \sigma \tau \ mgu(t_1 \iota' \sigma', t_2 \iota' \sigma') = \\ = \iota \sigma \ mgu(t_1 \iota \sigma, t_2 \iota \sigma) \ \tau_s$. Второе условие выполенено, так как оба дерева имеют высоту 0.
      
      Для конъюнкции и дизъюнкции утверждение напрямую следует из индукционных предположений (условие 1 нужно именно для возможности использования индукционного предположения при вычислении второго конъюнкта).
      
      Оставшиеся случаи требуют немного более тщательного анализа.
      
      В случае, когда $g = \lstinline|fresh ($x$) $g_2$|$, дальше в деревьях выводятся утверждения $\searchRule{\Gamma}{\iota[x \leftarrow \alpha]}{\sigma}{\delta \cup \alpha}{g}{S}$ и $\searchRule{\Gamma}{\iota'[x \leftarrow \alpha']}{\sigma'}{\delta' \cup \alpha'}{g}{S'}$ для некоторых $\alpha \not\in \delta$ и $\alpha' \not\in \delta'$. Мы можем использовать индукционное предположение для них, так как требования для множеств известных логических переменных в них очевидно выполняются, а в качестве подстановки приводящей более общее состояние к менее общему можно взять $\tau[\alpha \leftarrow \alpha']$: $\iota'[x \leftarrow \alpha'] \sigma' = \iota[x \leftarrow \alpha] \sigma \tau[\alpha \leftarrow \alpha']$, ведь $\sigma$ и $\sigma'$ не определены на $\alpha$ и $\alpha'$ соответственно, следовательно значение этих интерпретаций на $x$ равно $\alpha'$, на остальных идентификаторах они равны по определению $\tau$ (используя тот факт, что $\alpha$ не может встречаться в значениях интерпретации $\iota \sigma$ по одному из условий на $\delta$). Из индукционного предположения следует, что условие на высоты деревьев выполняется, а также что для любого решения $(\sigma'_s, \delta'_s) \in S'$ существует решение $(\sigma_s, \delta_s) \in S$ и подстановка $\tau_s$, такие что $\iota'[x \leftarrow \alpha'] \sigma_s' = \iota[x \leftarrow \alpha] \sigma_s \tau_s$.  Построим на её основе подстановку $\tau_{res}$, для которой $\iota' \sigma'_s = \iota \sigma_s \tau_{res}$. Сначала, используя лемму 1, представим подстановки из решения в виде $\sigma \Delta$ и  $\sigma' \Delta'$ (где $\Delta$ и $\Delta'$ ~--- некоторые подстановки, для которых верно $\mathcal{D}om(\Delta) \cap ((\delta \cup \{\alpha\}) \setminus \mathcal{VR}an(\iota[x \leftarrow \alpha] \sigma)) = \emptyset$ и $\mathcal{D}om(\Delta') \cap ((\delta' \cup \{\alpha'\}) \setminus \mathcal{VR}an(\iota'[x \leftarrow \alpha']  \sigma')) = \emptyset$). То есть необходимо получить $\iota' \sigma' \Delta' = \iota \sigma \Delta \tau_{res}$. Зададим подстановку следующим образом:
      
      \[\tau_{res}(\alpha_i) = \begin{cases}
      					                    \tau_s(\alpha_i), & \alpha_i \in \mathcal{VR}an(\iota[x \leftarrow \bot] \sigma) \\
      					                    \alpha_i \tau \Delta', & \alpha_i \not\in \mathcal{VR}an(\iota[x \leftarrow \bot] \sigma)
      					                  \end{cases} \]
    
      Покажем, что для неё выполняется $\alpha_i \tau \Delta' = \alpha_i \Delta \tau_{res}$ для всех $\alpha_i$ из $\mathcal{VR}an(\iota \sigma)$ (из этого очевидно следует нужное равенство, так как $\iota' \sigma' = \iota \sigma \tau$). На всех логических переменных из $\mathcal{VR}an(\iota[x \leftarrow \bot] \sigma)$ эти подстановки равны, так как верно $\iota[x \leftarrow \bot] \sigma \tau \Delta' = \iota[x \leftarrow \bot] \sigma \Delta \tau_s$ (возмем равенство, следовавшее из индукционного предположения, и сделаем обе интерпретации неопределенными на $x$, при этом $\tau[\alpha \leftarrow \alpha']$ можно заменить просто на $\tau$, так как $\alpha$ теперь нигде не встречается). Остальные переменные из $\mathcal{VR}an(\iota \sigma)$ не лежат в $\mathcal{VR}an(\iota[x \leftarrow \alpha] \sigma)$ (там лежат все переменные из предыдущего случая и $\alpha$, не лежащая в $\mathcal{VR}an(\iota \sigma)$), но лежат в $\delta$, поэтому, по условию на $\Delta$, $\Delta$ не определена на этих переменных и значения $\tau_{res}$ на них мы можем выбрать специально, чтобы выполнить равенство.
      
      Случай c вызовом отношения аналогичен. Множество известных логических переменных сокращается до значений всречающихся в интерпретациях определенных термов, подстановку на них можно получить из индукционного предположения, подстановку на остальных можно подобрать специально.
      
    \end{proof}
    
    Следующая лемма позволит получить нужные условия для использования леммы 2.
    
    \begin{lemma}$ $\par\nobreak\ignorespaces
    	  Для любых $\Gamma$, $\iota$, $\sigma$, $\delta$, $g$, и $S$, для любого дерева вывода утверждения $\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S}$, если вполнено условие $\mathcal{VR}an(\iota \sigma) \subset \delta$, то оно же выполнено для всех утверждений в дереве вывода, а также для любого $(\sigma_s, \delta_s)$ из $S$ верно $\mathcal{VR}an(\iota \sigma_s) \subset \delta_s$.
    	\end{lemma}
    \begin{proof}$ $\par\nobreak\ignorespaces
      Лемма доказывается простой индукцией по дереву вывода. В базовом случае мы снова пользуемся тем, что алгоритм унификации использует в итоговой подстановке только логические переменные встречающиеся в термах. Условие, наложенное на решения, добавлено специально для очевидного использования индукционного предположения в случае конъюнкции.
      
    \end{proof}
    
    Этих лемм достаточно для доказательства корректности критерия.
    
    \begin{theorem}
      Для любых $\Gamma$, $\iota$, $\iota'$, $\sigma$, $\sigma'$, $\delta$, $\delta'$, $r^k$, $a_1$, $\dots$, $a_k$, $b_1$, $\dots$, $b_k$, $S$, и $S'$, для любого дерева вывода утверждения 
      \[\searchRule{\Gamma}{\iota}{\sigma}{\delta}{\lstinline|$r^k$ $a_1$ $\dots$ $a_k$|}{S},\]
      если выполнено условие $\mathcal{VR}an(\iota \sigma) \subset \delta$ и в некотором его поддереве (не равном всему дереву) выводится утверждение
      \[\searchRule{\Gamma}{\iota'}{\sigma'}{\delta'}{\lstinline|$r^k$ $b_1$ $\dots$ $b_k$|}{S'},\]
      то $(b_1 \iota' \sigma', \dots, b_k \iota' \sigma') \nsucceq (a_1 \iota \sigma, \dots, a_k \iota \sigma)$.
    \end{theorem}
    \begin{proof}$ $\par\nobreak\ignorespaces
      Обозначим $v_i = a_i \iota \sigma$ и $v'_i = b_i \iota' \sigma'$. Предположим, что $(v'_1, \dots, v'_k) \succeq (v_1, \dots, v_k)$. Возьмем у данных дерева и поддерева поддеревья высоты на один меньше. В них будут выводится утверждения $\searchRule{\Gamma}{\epsilon[x_1 \leftarrow v_1, \dots, x_k \leftarrow v_k]}{\epsilon}{\delta}{g}{S}$ и $\searchRule{\Gamma}{\epsilon[x_1 \leftarrow v'_1, \dots, x_k \leftarrow v'_k]}{\epsilon}{\delta'}{g}{S'}$ для $\Gamma(r^k) = \lambda x_1 \dots x_k. g$. По лемме 3 также верно $\mathcal{VR}an(\iota' \sigma') \subset \delta'$. При этом $\epsilon[x_1 \leftarrow v_1, \dots, x_k \leftarrow v_k] \subset \mathcal{VR}an(\iota \sigma) \subset \delta$ и $\epsilon[x_1 \leftarrow v'_1, \dots, x_k \leftarrow v'_k] \subset \mathcal{VR}an(\iota' \sigma') \subset \delta'$. Эти факты и предположение позволяют применить лемму 2, и получить что поддерево, не равное всему дереву, имеет большую или равную высоту по сравнению со всем деревом. Противоречие.
    \end{proof}
    
    Так как представленная семантика задавала только исполнение программ с конечным поиском, незавершаемость можно описывать отсутствием дерева вывода. Таким же образом можно сформулировать следствие~--- сохранение завершаемости программ расширенным поиском (если программа завершалась при стандартном поиске, она будет завершаться и при расширенном), из которого очевидно следует сохранение опровергающей полноты расширенным поиском.
    
    \begin{corollary}
      Для любых $\Gamma$, $\iota$, $\sigma$, $\delta$, $g$, и $S$,
      
      \[ \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S} \Rightarrow \extSearchRule{\Gamma}{\iota}{\epsilon}{0}{\sigma}{\delta}{g}{S}, \]
      где $\epsilon$~--- пустое множество записей о предыдущих вызовах (всюду неопределенная функция).
    \end{corollary}
    \begin{proof}$ $\par\nobreak\ignorespaces
      Для индукционного доказательства утверждение нужно сформулировать в более общем виде: для любого $h$, если для любого $r^k$, такого что $h(r^k) = (v_1, \dots, v_n)$ для некоторых значений $v_i$, существует дерево вывода утверждения $\searchRule{\Gamma}{\iota'}{\sigma'}{\delta'}{\lstinline|$r^k$ $t_1$ $\dots$ $t_k$|}{S}$ для некоторых $t_i$, таких что $t_i \iota' \sigma' = v_i$, и у этого дерева есть поддерево, в котором выводится утверждение $\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S}$, тогда $\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S} \Rightarrow \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g}{S}$.
      
      Это утверждение доказывается идукцией по дереву вывода утверждения в семантике стандартного поиска, строится аналогичное дерево в семантике расширенного поиска.
      
      Во всех случаях, кроме вызова отношения можно использовать при построении те же самые правила. В случае вызова отношения необходимо так же знать, что текущие значения аргументов не являются более общими, чем значения аргументов при предыдущем вызове (хранящиеся в $h$), но это следует из корректности критерия (чтобы применить его формально, используется условие на $h$ из формулировки утверждения).
      
    \end{proof}
    
    Неформально так же понятно, что расширение поиска является консервативным, то есть изменения в выполнении программы произойдут только при выполнении критерия незавершаемости на некотром этапе исполнения, поэтому сохранение опровергающей полноты удастся доказать для расширения поиска с любым другим критерием, если доказана его корректность. 
 
  \section{Реализация и апробация}
  
    Прототип расширенного поиска был реализован на базе OCanren. Для реализации потребовалось изменить тип встраивания на deep embedding, чтобы получить возможность отслеживать вызовы отношений. При этом интерфейс использования отношений сохранен~--- расширенный поиск также можно прервать после нахождения определенного числа решений, и если обычный поиск находил столько решений, то и расширенный найдёт (возможно другие, но корректные).

    Подход был испытан на нескольких известных примерах реляционных программ.
    
    Примером, хорошо демонстрирующим проблему, с которой мы боремся, является генерация перестановок с помощью реляционной сортировки~\cite{ocanren}.
    
\begin{lstlisting}
  let rec minmax$^o$ a b min max =
    (le$^o$ a b /\ min === a /\ max === b) \/
    (gt$^o$ a b /\ min === b /\ max === a)
  
  let rec smallest$^o$ l s l' =
    (l === [s] /\ l' === []) \/
    (fresh (h t s' t' max)
      (l' === max :: t') /\
      (l === h :: t) /\
      (minmax$^o$ h s' s max) /\
      (smallest$^o$ t s' t'))
   
   let rec sort$^o$ xs ys =
    (xs === [] /\ ys === []) \/
    (fresh (y ys' xs')
      (ys === y :: ys') /\
      (smallest$^o$ xs y xs') /\
      (sort$^o$ xs' ys'))
\end{lstlisting}

    Сортировка описывается естественным образом, с использованием отношений \lstinline|smallest$^o$ l s l'|~--- ``\lstinline|s| является наименьшим элементом списка \lstinline|l|, а список \lstinline|l'| содержит остальные его элементы в том же порядке'' и \lstinline|minmax$^o$ a b min max|~--- ``значение \lstinline|min| равно значению наименьшего элемента среди \lstinline|a| и \lstinline|b|, а значение \lstinline|max|~--- значению наибольшего''. Как и всегда она может быть использована для сортировки некоторого списка, если мы фиксируем значение \lstinline|xs|, и для генерации всех перестановок заданного сортированного списка, если мы фиксируем значение \lstinline|ys|. В последнем случае стандартный поиск будет расходиться для любого непустого списка \lstinline|ys| и причина здесь тоже в некоммутативности конъюнкции: в момент вызова \lstinline|smallest$^o$| в функции \lstinline|sort$^o$| известно только значение \lstinline|y|, поэтому начинают перебираться все списки с наименьшем элементом \lstinline|y|, которых очевидно бесконечно много. Даже если мы зададим заранее количество ответов, их поиск займет немыслимо большое время для списков длины больше $2$, ведь алгоритм остается тем же: перебирать все списки у которых наименьший элемент совпадает с первым элементом данного списка до тех пор, пока не встретится перестановка данного списка (причем проверка заключается в рекурсивном вызове того же алгоритма).
  
    Ситуацию можно исправить, поменяв местами два последних конъюнкта в \lstinline|sort$^o$|. Тогда значение \lstinline|ys'| также станет известно к моменту вызова \lstinline|smallest$^o$| и алгоритм генерации перестановок станет разумным. К сожалению, после этого изменения порядка поиск перестанет работать при использовании отношения непосредственно для сортировки (также расходимость на непустых списках и обозримое время нахождения решений только для списков длины не превосходящей $3$) по сходным причинам.
  
    Более того, если мы захотим использовать это отношение, чтобы задать перестановку произвольного (не обязательно сортированного) списка, мы получим отношение, использующее сортировку сразу в обе стороны.

\begin{lstlisting}
   let rec perm$^o$ xs ys =
     fresh (ss)
       (sort$^o$ xs ss) /\
       (sort$^o$ ys ss)
\end{lstlisting}

    Поэтому независимо от порядка в определении \lstinline|sort$^o$| поиск будет расходиться, а время нахождения решения будет неприемлимым для списков длины больше $3$. Пока неизвестна версия этого отношения, опровергающе полная при стандартном поиске.
  
    В то же время расширенный поиск на этом отношении будет завершаться независимо от выбранного порядка: нужный порядок для каждого вызова будет востановлен в процессе исполнения программы. Благодаря этому запросы будут исполнятся за разумное время (практически независимое от того, задаем ли мы число ответов заранее) на разумных длинах списков (до 8-9, ведь число решений равно факториалу, если все элементы различны).

    Другим показательным примером является реляционная двоичная арифметика (включает сложение, умножение, операции сравнения и деление с остатком). Известно, что наивная ``функциональная'' реализация для завершаемости поиска требует разных порядков в конъюнкциях для разных запросов. Для решения этой проблемы текущая реализация использует продвинутую технику ограничения размера термов~\cite{KiselyovArithmetic}, потому трудна для понимания без значительного опыта в реляционном программировании.
    
    Расширенный поиск, в свою очередь, восстанавливает нужный порядок дя каждого запроса в процессе исполнения программы, и поэтому позволяет писать простые завершающиеся определения операций, со схожей (а на некоторых запросах~--- ощутимо большей) эффективностью.
    
    Например, если при стандартном поиске для завершаемости деление с остатком реализуется сложным рекурсивным отношением из 20 строчек кода, не включая вспомогательных отношений, при расширенном поиске достаточно записать определение.
    
\begin{lstlisting}
   let rec div$^o$ x y q r =
     fresh (yq)
       (mult$^o$ y q yq) /\
       (plus$^o$ yq r x) /\
       (lt$^o$ r y)
\end{lstlisting}

    Расширенный поиск также позволяет решать проблемы ещё в нескольких содержательных отношениях, включая опровержимую неполноту отношения разворачивания списка и незавершимость противоречивых запросов к простому интерпретатору. На данный момент, для всех естественных отношений (а не специально сконструированных контрпримеров) расширение поиска позволяет исправить незавершаемость, вызываемую некоммутативностью конъюнкции.
    
  \section{Заключение}
  
    В рамках работы были получены следующие результаты:
    
    \begin{itemize}
      \item сформулирован конкретный критерий незавершаемости реляционных программ и предложено расширение реляционного поиска, изменяющее направление поиска полагаясь на него;
      \item описаны операционные семантики большого шага для стандартного и расширенного поиска, с их использованием формально доказаны корректность предложенного критерия и сохранение опровергающей полноты расширенным поиском;
      \item реализован прототип расширенного поиска и продемонстрирована его способность исправлять незавершаемость ряда важных отношений.
    \end{itemize}
    
  \subsection{Ограничения}
  
    Текущая реализация расширенного поиска значительно полагается на deep embedding языка. Так как в подавляющем большинстве реализаций MiniKanren используется shallow embdding, для добавления расширения в некоторую версию скорее всего придется предварительно совершить этот переход (что в целом является технической задачей).
    
    В семантиках и, соответственно, доказательствах используется простеший вариант языка, поэтому нет никаких гарантий что критерий расходимости будет работать корректно при использовании некоторых расширений языка (например, OCanren также поддерживает disequality constraint~--- возможность задавать в качестве отношения неравенство двух термов). Возможно, критерий придется специально адаптировать для них.
    
    Наконец, текущая реализация расширения создана с целью проверки его способности исправлять незавершаемость некоторых программ и приемлимой эффективности, а не для реального использования. Поэтому на данный момент расширение поиска может приводить к значительному замедлению поиска в случае завершающихся изначально программ (до 10 раз, что, впрочем, является незначительным по сравнению с замедлением от неправильной стратегии поиска). Но это скорее ограничение реализации, а не подхода, поэтому возможно это замедление можно значительно уменьшить.
    
  \subsection{Дальнейшая работа}
  
    В дальнейшем в первую очередь планируется изучить способы эффективного добавления данного расширения в текущую реализацию OCanren.
    
    Также планируется исследовать применение данного подхода к сложным интерпретаторам (например, допускающим рекурсивные определения) и их использованию для генерации программ.
    
    Кроме того, хотелось бы формализовать имеющиеся доказательства (несколько перегруженные деталями) в какой-нибудь системе автоматической проверки доказательств.
  
    \begin{thebibliography}{99}

      \bibitem{TRS}
      Daniel P. Friedman, William E.Byrd, Oleg Kiselyov. The Reasoned Schemer. The MIT
      Press, 2005.

      \bibitem{WillThesis}
      William E. Byrd. Relational Programming in miniKanren: Techniques, Applications, and Implementations. PhD Thesis,
      Indiana University, Bloomington, IN, September 30, 2009.
      
      \bibitem{Interleaving}
      Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, Amr Sabry.
      Backtracking, interleaving, and terminating monad transformers: (functional pearl) //
      Proceedings of the 10th ACM SIGPLAN International Conference on Functional Programming (ICFP '05).

      \bibitem{CKanren}
      Claire E. Alvis, Jeremiah J. Willcock, Kyle M. Carter, William E. Byrd, Daniel P. Friedman.
      cKanren: miniKanren with Constraints //
      Proceedings of the 2011 Workshop on Scheme and Functional Programming (Scheme '11).
      
      \bibitem{alphaKanren}
      William E. Byrd, Daniel P. Friedman. alphaKanren: A Fresh Name in Nominal Logic Programming //
      Proceedings of the 2007 Workshop on Scheme and Functional Programming (Scheme '07).

      \bibitem{Untagged}
      William E. Byrd, Eric Holk, Daniel P. Friedman.
      miniKanren, Live and Untagged: Quine Generation via Relational Interpreters (Programming Pearl) //
      Proceedings of the 2012 Workshop on Scheme and Functional Programming (Scheme '12).
      
      \bibitem{unified}
      William E. Byrd, Michael Ballantyne, Gregory Rosenblatt, Matthew Might. A Unified Approach to Solving Seven Programming Problems // 
      Proceedings of the International Conference on Functional Programming, 2017.
      
      \bibitem{KiselyovArithmetic}
      Oleg Kiselyov, William E. Byrd, Daniel P. Friedman, Chung-chieh Shan.
      Pure, declarative, and constructive arithmetic relations (declarative pearl) //
      Proceedings of the 9th International Symposium on Functional and Logic Programming, 2008.
      
      \bibitem{ocanren}
      Dmitry Kosarev, Dmitry Boulytchev. Typed Embedding of a Relational Language in OCaml // International Workshop on ML, 2016.
      
      \bibitem{Unification}
     Franz Baader, Wayne Snyder.
     Unification theory.
     John Alan Robinson and Andrei Voronkov, editors,
     Handbook of Automated Reasoning. Elsevier and MIT Press, 2001.
      
      \bibitem{MiniKanrenOrg}
      \url{http://minikanren.org/}

    \end{thebibliography}
