\title{Применение парсер-комбинаторов для разбора булевых грамматик}

\titlerunning{Применение парсер-комбинаторов для разбора булевых грамматик}

\author{Курбатова Зарина Идиевна}

\authorrunning{З.И.Курбатова}

\tocauthor{З.И.Курбатова}
\institute{Санкт-Петербургский государственный университет\\
\email{zarina.kurbatova@gmail.com}}

\maketitle

\begin{abstract}
  Булевы грамматики являются расширением контекстно-свободных грамматик, которое позволяет
  использовать конъюнкцию и отрицание в правилах вывода. В рамках данной работы была
  разработана принтер-комбинаторная библиотека для разбора булевых грамматик. Для
  получения приемлемой производительности и поддержки левой рекурсии в библиотеке были
  использованы техники мемоизации и CPS (continuation-passing style).
\end{abstract}

\section*{Введение} 
Языки программирования имеют строгую синтаксическую структуру, которую можно успешно описать с использованием формальных грамматик. Согласно иерархии Н.Хомского \cite{chomsky1956three}, формальные грамматики делятся на 4 вида:  неограниченные, контекстно-свободные, контекстно-зависимые и регулярные. Как известно, с помощью контекстно-свободных грамматик может быть описан весьма узкий класс языков. Существует расширение контекстно-свободных грамматик -- булевы грамматики, предложенные А.Охотиным \cite{okhotin2004boolean}. Булевы грамматики более выразительны, поскольку позволяют использовать конъюнкцию и отрицание в правых частях правил вывода.


Задачу синтаксического анализа можно сформулировать как задачу определения принадлежности слова некоторому языку. Иными словами, синтаксический анализатор принимает на вход строку и определяет, может ли грамматика задаваемого языка порождать введенную строку. Одним из популярных подходов к реализации синтаксических анализаторов является парсер-комбинаторная техника: анализаторы представляются функциями высших порядков \cite{hutton1996monadic}. Парсер-комбинаторы -- это функции высшего порядка, принимающие в качестве параметров анализаторы и возвращающие в качестве результата анализатор. Анализатор, в свою очередь, принимает в качестве входа строку и возвращает некоторый результат. При данном подходе определяются базовые комбинаторы, а затем с их помощью определяются более сложные. Например, в качестве базовых комбинаторов можно использовать комбинатор последовательного применения и комбинатор альтернативного применения. 
Основной проблемой наивной реализации подхода является невозможность использования левой рекурсии. Существуют различные реализации данной техники, поддерживающие левую рекурсию. Например, в работе \cite{spiewak2010generalized} решение основано на алгоритме обобщенного синтаксического анализа GLL.


Синтаксический анализ находит применение во многих областях. В биоинформатике одной из основных задач является поиск в геноме особых участков, кодирующих белок, тРНК и др. Геном представляет собой последовательность нуклеотидов или, другими словами, строку над алфавитом $\{A, C, G, T\}$. Искомые подстроки генома могут быть описаны с помощью контекстно-свободной грамматики. Таким образом, необходимо находить все строки, обладающие свойством выводимости. Например, вторичная структура РНК может быть описана с помощью контекстно-свободной грамматики, поскольку является своего рода языком палиндромов. Поэтому методы синтаксического анализа применимы при решении задач биоинформатики \cite{sippl1999biological}.

\section{Постановка задачи}

Целью данной работы является изучение применимости парсер-комбинаторной техники
для разбора булевых грамматик. Для ее достижения были поставлены следующие задачи:

\begin{itemize}
    \item реализация эффективной парсер-комбинаторной библиотеки для разбора булевых грамматик с поддержкой левой рекурсии;
    \item апробация библиотеки на примере контекстно-свободной грамматики, булевой грамматики и грамматики из биоинформатики;
    \item сравнение с существующими решениями.
\end{itemize}

\section{Обзор предметной области}
В данной главе определены основные понятия и приведено описание техник, использованных при реализации парсер-комбинаторной библиотеки.

    \subsection{Парсер-комбинаторы}
В функциональном программировании представление анализаторов функциями и определение функций высших порядков (комбинаторов) является популярным подходом к построению нисходящих синтаксических анализаторов. При данном подходе определяются базовые комбинаторы и примитивные анализаторы, например, для разбора пустой строки и терминального символа.

Рассмотрим несколько таких комбинаторов.

\begin{lstlisting}[language=Haskell, frame=top, frame=bottom, tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Комбинатор seq}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
seq      :: Parser a -> Parser b -> Parser (a,b)
p 'seq' q = \s -> [((v,w), s'') | (v, s')   <- p s
                                , (w, s'')  <- q s']
\end{lstlisting}

Комбинатор последовательного применения \lstinline[language=Haskell]{seq} принимает на вход два анализатора \lstinline[language=Haskell]{p}, \lstinline[language=Haskell]{q} и возвращает анализатор, который последовательно запускает анализатор\lstinline[language=Haskell]{p} и \lstinline[language=Haskell]{q}. В качестве результата \lstinline[language=Haskell]{seq} возвращает список пар вида \lstinline[language=Haskell]{(x, y)}, где \lstinline[language=Haskell]{x} - пара из результатов разбора \lstinline[language=Haskell]{p} и \lstinline[language=Haskell]{q}, \lstinline[language=Haskell]{y} - оставшаяся часть входного потока.

\begin{lstlisting}[language=Haskell, frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Комбинатор bind}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
bind      :: Parser a -> (a -> Parser b) -> Parser  b
p 'bind' f = \s -> concat[f v s' | (v, s') <- p s]
\end{lstlisting}
   
Анализатор \lstinline[language=Haskell]{p} применяется к входной строке \lstinline[language=Haskell]{s} и возвращает список пар вида (значение, строка). Функция \lstinline[language=Haskell]{f} берет значение и возвращает анализатор, который применяется к каждому значению по очереди. В результате \lstinline[language=Haskell]{bind} вернет список пар вида (значение, строка).
   
Однако наивная реализация этого подхода может иметь экспоненциальную сложность разбора, еще одним недостатком является невозможность использования леворекурсивных правил. %В главе "Обзор существующих решений" будет представлено несколько вариантов устранения описанных недостатков.
   
    \subsection{Булевы грамматики}
    
На практике часто встречаются языки,  которые нельзя описать с помощью контекстно-свободных грамматик.
Например, рассмотрим язык $\{a^{m}b^{n}c^{n} |m, n \geq 0, m \neq n\}$, которой не является контекстно-свободным. Его можно задать с помощью булевой грамматики:

\begin{lstlisting}[ basicstyle=\itshape, xleftmargin=3em,
        literate={->}{$\rightarrow$}{2}
           {α}{$\alpha$}{1}
           {δ}{$\delta$}{1}
           {e}{$\varepsilon$}{1}
           {not}{$\neg$}{1}
           {and}{$\&$}{1}
           {or}{$|$}{1}
           ]
     S -> AB and not DC 
     A -> aA  or e
     B -> bBc or e  
     C -> cC  or e  
     D -> aDb or e 
\end{lstlisting}
 Рис.1: Булева грамматика для языка $\{a^{m}b^{n}c^{n} |m, n \geq 0, m \neq n\}$ \\
 
Булева грамматика - это четверка $G = (\Sigma, N, P, S)$, где:
    \begin{itemize}
        \item $\Sigma$ -- конечное непустое множество терминалов;
        \item $N$ -- конечное непустое множество нетерминалов;
        \item $P$ -- конечное множество правил.
    \end{itemize}

Каждое правило имеет следующий вид:
    \[A \rightarrow \alpha_1 \&...\&\alpha_m\&\neg \beta_1 \&...\&\neg \beta_n \]
    \[(m + n \geq 1, \alpha_i, \beta_i \in (\Sigma \cup N)^{*}) \]
    
Правило $A$ можно интерпретировать следующим образом: если строка представима в форме $\alpha_1 ,...,\alpha_m$, но не представима в форме $\beta_1 .,...,\beta_n$, то она выводится из нетерминала $A$.

Булевы грамматики расширяют контекстно-свободные грамматики, позволяя использовать в правых частях правил вывода конъюнкцию и отрицание.

    \subsection{Continuation Passing Style}
    Наивная реализация парсер-комбинаторного подхода имеет несколько ограничений. Во-первых, при наивном подходе имеет значение порядок альтернатив: анализатор завершает работу, пройдя по первой успешной альтернативе. Во-вторых, анализатор возвращает лишь одно дерево вывода. Поскольку потенциально анализатор может успешно завершить работу несколько раз на одной позиции во входном потоке, для разбора неоднозначных грамматик необходим исчерпывающий поиск, т.е. поиск всех возможных выводов строки. Одним из способов достичь этого является техника программирования в стиле передачи продолжений (Continuation Passing Style). Идея техники заключается в передаче управления через механизм продолжений. Продолжение представляет собой состояние программы, в которое может быть осуществлен переход из любой точки программы.
    
    Рассмотрим простой пример -- определение функции, возводящей число в квадрат. 
    
        \begin{lstlisting}[language=Haskell, frame=top, frame=bottom , tabsize=2, inputencoding=utf8x, caption={Обычное определение функции}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
        square :: Int -> Int
        square x = x*x
        \end{lstlisting}

        \begin{lstlisting}[language=Haskell, frame=top, frame=bottom , tabsize=2, inputencoding=utf8x, caption={Определение функции в стиле передачи продолжений}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
        square_cps :: Int -> (Int -> c) -> c
        square_cps x k = k (x*x)
        \end{lstlisting}
        
    У каждой функции есть дополнительный аргумент -- функция, которой будет передан результат. В примере выше \lstinline[language=Haskell]{k} -- это продолжение, которому передается результат возведения числа в квадрат. Например, в качестве продолжения может быть передана функция, выводящая результат в консоль.
        
    \subsection{Мемоизация вычислений синтаксического анализа}
    Использование мемоизации при построении нисходящих синтаксических анализаторов для избежания экспоненциального времени анализа впервые было предложено в работе \cite{norvig1991techniques}. Идея техники заключается в сохранении результата работы анализатора для предотвращения повторых вычислений: если анализатор уже вызывалась на {\tt i}-ой позиции, возвращается результат из таблицы, в противном случае анализатор запускается на позиции {\tt i}, а результат затем помещается в таблицу. 
    
    \subsection{Поддержка левой рекурсии}

При наивной реализации парсер-комбинаторного подхода вызов анализатора на грамматике вида ${E \rightarrow E \ E \ | \ a \ | \ \varepsilon}$ не завершится, поскольку анализатор зациклится. В связи с этим становится актуальным вопрос поддержки левой рекурсии. В данном разделе описан подход к поддержке леворекурсивных правил. Впервые он был представлен в работе \cite{johnson1995memoization}. 

Заведем функцию {\tt memo}, которая принимает на вход анализатор {\tt f} и возвращает его мемоизированную версию, которая каждый раз при вызове на {\tt i}-ой позиции обращается к таблице мемоизации. Если анализатор уже вызывался на {\tt i}-ой позиции, то возвращается соответствующее значение, в противном случае вызывается функция memoresult с аргументом {\tt f(i)}. Благодаря стратегии call-by-name анализатор {\tt f} не запускается на позиции {\tt i}, что гарантирует единственность вызова. Функция memoresult возвращает объект, у которого есть доступ к двум спискам: {\tt Rs} хранит позиции, на которых работа анализатора завершилась успешно, {\tt Ks} хранит все продолжения, переданные немемоизированному анализатору при вызове на {\tt i}-ой позиции. Если анализатор вызван впервые, то текущее продолжение добавляется к списку {\tt Ks}. При вызове анализатора на позиции {\tt j}, которой нет в {\tt Rs}, сначала {\tt j} добавляется  в {\tt Rs}, затем запускаются все продолжения из {\tt Ks} на {\tt j}-ой позиции. Если анализатор уже вызывался, то текущее продолжение добавляется к {\tt Ks} и вызывается для каждой позиции из {\tt Rs}.

Теперь, когда мемоизированный анализатор вызывается на {\tt i}-ой позиции, его завершение будет гарантировано, поскольку не будет вызван на {\tt i}-ой позиции больше одного раза.
    
\subsection{Существующие решения}
В данном разделе приведен обзор парсер-генераторной библиотеки с поддержкой булевых грамматик и двух парсер-комбинаторных библиотек.
\subsubsection{Whale Calf}

Whale Calf\footnote{\url{http://users.utu.fi/aleokh/whalecalf/}} - инструмент для разбора булевых грамматик, реализованный А.Охотиным на языке {\tt C++}. Инструмент состоит из двух компонент: парсер-генератор, который преобразует текстовое описание конъюнктивных грамматик в исполняемый код, и библиотека, которая используется для анализа грамматик. В библиотеке реализовано несколько алгоритмов синтаксического анализа: табличный алгоритм для грамматик в бинарной нормальной форме, табличный алгоритм для грамматик в линейной нормальной форме, табличный алгоритм для произвольных грамматик, конъюнктивный LL, конъюнктивный LR и алгоритм, основанный на эмуляции автоматов, эквивалентных линейным конъюнктивным грамматикам. 

Рассмотрим пример описания грамматики в контексте данной библиотеки.
\begin{lstlisting}[ frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Описание грамматики для языка $\{\omega c \omega |\omega \in {a, b}^{*}\}$}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
algorithm=LR;
terminal a, b, c;

S -> C & D;
C -> a C a | a C b | b C a | b C b | c;
D -> a A & a D | b B & b D | c E;
A -> a A a | a A b | b A a | b A b | c E a;
B -> a B a | a B b | b B a | b B b | c E b;
E -> a E | b E | e;
\end{lstlisting}

Whalf Calf обрабатывает файл с описанием грамматики и создает два файла с определением анализатора на языке {\tt C++} -- {\tt filename.cpp} и {\tt filename.h}. Рассмотрим несколько методов, представленных в примере ниже:
\begin{itemize}
    \item {\tt read()} используется для передачи входной строки;
    \item {\tt recognize()} используется для определения принадлежности строк языку;
    \item {\tt parse()} используется для построения дерева вывода.
     
\end{itemize}

\begin{lstlisting}[ language=C++, frame=top, frame=bottom , basicstyle=\small, tabsize=2, inputencoding=utf8x, caption={Пример использования анализатора}]
int x[] = {0, 1, 2, 0, 1}; // input "abcab"
whale_calf.read(x, x + 5);
WhaleCalf::TreeNode *tree = whale_calf.parse();
if (tree) whale_calf.print_tree(ofstream("parse_tree.dot"));
\end{lstlisting}

Данная реализация имеет сложность $O(n^{4})$ по времени. Утверждается, что на практике работает быстрее, чем реализации других алгоритмов, имеющих в худшем случае сложность $O(n^{3})$.


\subsubsection{Meerkat}
Meerkat\footnote{\url{http://meerkat-parser.github.io/}} - парсер-комбинаторная библиотека с поддержкой всех контекстно-свободных грамматик, в том числе содержащих леворекурсивные правила, написанная на языке {\tt Scala}. Библиотека позволяет строить дерево разбора за линейное время на грамматиках реальных языков программирования и за кубическое время в худшем случае. Помимо прочего, строится SPPF (Shared Packed Parse Forest) -- графовое представление семейства деревьев разбора. Описание подхода к поддержке левой рекурсии описано авторами в работе \cite{izmaylova2016practical}.

%TODO
%% \begin{lstlisting}[ language=Scala, frame=top, frame=bottom , basicstyle=\small, tabsize=2, inputencoding=utf8x, caption={Описание грамматики арифметических выражений в библиотеке Meerkat}]
%% val E: OperatorNonterminal
%% = syn ( right ( E ~ "^" ~ E )
%%       |> "-" ~ E 
%%       |> left ( E ~ "*" ~ E 
%%       | E ~ "/" ~ E )
%%       |> left ( E ~ "+" ~ E 
%%       | E ~ "-" ~ E )
%%       | "(" ~ E ~ ")"
%%       | "[0-9]".r
%%       )
%% \end{lstlisting}
В языке Scala функции и переменные могут состоять из любых символов, например, можно создать функцию с именем $\sim$. В примере выше | - комбинатор альтернативного применения, $\sim$ - комбинатор последовательного применения. Для указания приоритета используется |>, для указания левой и правой ассоциативности используются \lstinline[language=Scala]{left} и \lstinline[language=Scala]{right} соотвественно. Терминальные символы могут быть представлены строками - $``-''$, $``+''$, $``*''$ и т.д.

\section{Реализация}

В данном разделе описана реализация парсер-комбинаторной библиотеки.

В качестве языка для реализации выбран Kotlin\footnote{\url{http://kotlinlang.org/}}. Kotlin -- это молодой язык программирования, поддерживающий объектно-ориентированную и функциональную парадигмы, разрабатывается компанией JetBrains\footnote{\url{http://jetbrains.com/}}. Поскольку Kotlin базируется на JVM, на ранних этапах разработки библиотеки была актуальна проблема переполнения стека из-за большого количества функциональных вызовов. Решить проблему удалось, воспользовавшись техникой программирования в стиле передачи продолжений (Continuation Passing Style).
  
    \subsection{Интерфейс библиотеки}
  
Анализатор имеет тип \lstinline[language=Scala]{Recognizer<A>}, принимает на вход позицию во входном потоке и возвращает функцию типа \lstinline[language=Scala]{CPSResult<A>}. Эта функция принимает на вход продолжение типа \lstinline[language=Scala]{K<A>} и возвращает \lstinline[language=Scala]{Unit}. Тип \lstinline[language=Scala]{Unit} эквивалентен типу {\tt void} в других языках программирования. Продолжение представляет собой следующий этап синтаксического анализа. Анализ производится вне зависимости от порядка
    альтернатив, таким образом обеспечивается исчерпывающий поиск. 
    
  \begin{lstlisting}[language=Scala, frame=top, frame=bottom , tabsize=2, inputencoding=utf8x, caption={Основные типы}, literate={->}{$\rightarrow$}{2}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
  typealias Recognizer<A> = (Int)    -> CPSResult<A> 
  typealias CPSResult <A> = (K<A>)   -> Unit
  typealias K<A>          = (Int, A) -> Unit
  \end{lstlisting}
  
  В библиотеке реализовано множество различных анализаторов и комбинаторов, среди которых можно выделить несколько базовых:
  \begin{itemize}
      \item \lstinline[language=Scala]{terminal} - принимает на вход строку \lstinline[language=Scala]{s} и проверяет, начинается ли входная строка с подстроки \lstinline[language=Scala]{s};
      \item \lstinline[language=Scala]{eps} -- анализатор для пустой строки;
      \item \lstinline[language=Scala]{rule} -- комбинатор альтернативного применения;
      \item \lstinline[language=Scala]{seq} -- комбинатор последовательного применения;
      \item \lstinline[language=Scala]{map} -- принимает на вход анализатор \lstinline[language=Scala]{ p} и функцию \lstinline[language=Scala]{f}, применяет \lstinline[language=Scala]{ f} к результату работы \lstinline[language=Scala]{p};
      \item \lstinline[language=Scala]{fix} -- комбинатор неподвижной точки, используется для определения рекурсивных правил;
      \item \lstinline[language=Scala]{number} -- анализатор чисел;
      \item \lstinline[language=Scala]{symbol} -- анализатор последовательности букв и чисел;
      \item \lstinline[language=Scala]{paren} -- принимает на вход анализатор\lstinline[language=Scala]{f} и проверяет, заключен ли результат \lstinline[language=Scala]{f} в круглые скобки во входной строке.
  \end{itemize}
  
   В качестве примера работы с библиотекой рассмотрим реализацию анализатора для языка While. While -- простой язык программирования, в котором определены следующие конструкции: присваивание, последовательная композиция, условный оператор и while.
   
   Определение анализатора для разбора выражений приведено в листинге 9. Оператор $"/"$ представляет собой синтаксический сахар для комбинатора альтернативного применения. 
  
  \begin{lstlisting}[language=Scala, frame=top, frame=bottom , basicstyle=\small, numbers=left, tabsize=2, inputencoding=utf8x, caption={Анализатор выражений для языка While}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2} {percent}{$\%$}{2}]
val exprParser: Recognizer<Expr> = fix {
    val corep = (number map { Expr.Con(it) as Expr }) /
                (symbol map { Expr.Var(it) as Expr }) /
                paren( sp(it) )
    val op1p = rightAssocp(sp(terminal("^")), corep) {
                    l, op, r -> Expr.Binop(l, op, r) 
            }
    val op2p =
      rightAssocp(sp(terminal("*") / terminal("/") / 
        terminal("percent")), op1p) {
          op, e1, e2 ->
            Expr.Binop(op, e1, e2)
        }
    val op3p =
      assocp(sp(terminal("+") / terminal("-")), op2p) {
        op, e1, e2 ->
          Expr.Binop(op, e1, e2)
      }
    return@fix op3p
}
  \end{lstlisting}
  
  
  \subsection{Поддержка булевых грамматик}
Для поддержки булевых грамматик необходимо определить две операции -- конъюнкцию и отрицание. Комбинатор \lstinline[language=Scala]{And}, реализующий операцию конъюнкция, должен находить пересечение языков, порождаемых поступившими на вход анализаторами. Если входная строка принадлежит пересечению, то анализ завершается успешно. Комбинатор \lstinline[language=Scala]{AndNot}, реализующий операцию отрицание, завершает работу успешно, если входная строка принадлежит одному языку, а другому -- нет. Ниже приведено подробное описание реализации обоих комбинаторов.

Комбинатор And принимает в качестве параметров два анализатора \lstinline[language=Scala]{p1} и \lstinline[language=Scala]{p2} и возвращает анализатор, который работает следующим образом: 
\begin{itemize}
    \item хранит два списка пар  для \lstinline[language=Scala]{p1} и \lstinline[language=Scala]{p2} соответственно вида \lstinline[language=Scala]{<Int, A>}, где первый параметр - номер позиции во входном потоке, второй параметр - обработанный символ входного потока;
    \item запускает оба анализатора на \lstinline[language=Scala]{i}-ой позиции с продолжением, которое принимает пару вида \lstinline[language=Scala]{<Int, A>}, где первый параметр - \lstinline[language=Scala]{pos} - позиция во входном потоке, второй параметр - \lstinline[language=Scala]{res} - обработанный символ входного потока. Добавляет пару в соответствующий список пар для анализатора \lstinline[language=Scala]{p1(p2)}. Проверяет, есть ли ли в соответствующем списке для анализатора \lstinline[language=Scala]{p2(p1)} пара, в которой первый элемент соответствует равен \lstinline[language=Scala]{pos}. Если да, то исходному продолжению передается пара, состоящая из \lstinline[language=Scala]{pos} и пары, которая состоит из \lstinline[language=Scala]{pos} и \lstinline[language=Scala]{res};
    \item анализатор сообщает, что строка принадлежит пересечению конъюнктов, если порождается и анализатором \lstinline[language=Scala]{p1}, и анализатором \lstinline[language=Scala]{p2}.
\end{itemize}

\begin{lstlisting}[language=Scala, frame=top, frame=bottom , basicstyle=\small, numbers=left, tabsize=2, inputencoding=utf8x, caption={Код комбинатора And}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
class And<A, B> (
val p1: Recognizer<A>, val p2: Recognizer<B>
) : Recognizer<Pair<A, B>>() {
    override fun invoke(p: Int): CPSResult<Pair<A, B>> {
        val passedByp1: ArrayList<Pair<Int, A>> = ArrayList()
        val passedByp2: ArrayList<Pair<Int, B>> = ArrayList()
        val executed  : ArrayList<Pair<Int, Pair<A, B>>> =
          ArrayList()

        return { k: K<Pair<A, B>> ->
            p1(p)({ pos: Int, res: A ->
                val pair1p = Pair(pos, res)
                passedByp1.add(pair1p)
                passedByp2.forEach { r ->
                    if (pair1p.first == r.first) {
                        val kpair =
                          Pair(pair1p.second, r.second)
                        k(pos, kpair)
                        executed.add(Pair(pos, kpair))
                    }
                }
            })

            p2(p)({ pos: Int, res: B ->
                val pair2p = Pair(pos, res)
                passedByp2.add(pair2p)
                passedByp1.forEach { r ->
                    if (pair2p.first == r.first) {
                        val kpair =
                          Pair(r.second, pair2p.second)
                        k(pos, kpair)
                        executed.add(Pair(pos, kpair))
                    }
                }
            })
        }
    }
}
\end{lstlisting}
Строка выводится по правилу $S \rightarrow A \& \neg B$, если она может быть порождена из нетерминала $A$ и не может быть порождена из нетерминала $B$. Таким образом, нужен комбинатор \lstinline[language=Scala]{AndNot}, проверяющий это условие.
В качестве параметров комбинатор \lstinline[language=Scala]{AndNot} принимает два анализатора \lstinline[language=Scala]{p1} и \lstinline[language=Scala]{p2} и возвращает анализатор, который работает следующим образом:
\begin{itemize}
    \item хранит два списка пар  для \lstinline[language=Scala]{p1} и \lstinline[language=Scala]{p2} соответственно вида \lstinline[language=Scala]{<Int, A>}, где первый параметр - номер позиции во входном потоке, второй параметр - обработанный символ входного потока;
    \item запускает анализатор \lstinline[language=Scala]{p1} на \lstinline[language=Scala]{i}-ой позиции с продолжением, которое добавляет пару типа \lstinline[language=Scala]{<Int, A>} в соответствующий список для \lstinline[language=Scala]{p1}. Эта пара передается продолжению \lstinline[language=Scala]{k}, если анализ прошел успешно;
    \item затем запускает анализатор \lstinline[language=Scala]{p2} на \lstinline[language=Scala]{i}-ой позиции;
    \item если анализатор \lstinline[language=Scala]{p2} не разобрал входную строку до той же позиции, что и анализатор \lstinline[language=Scala]{p1}, то анализ входной строки завершается успешно.
\end{itemize}

\begin{lstlisting}[language=Scala, frame=top, frame=bottom , basicstyle=\small, numbers=left, tabsize=2, inputencoding=utf8x, caption={Код комбинатора AndNot}, literate={->}{$\rightarrow$}{2} {<-}{$\leftarrow$}{2}]
class AndNot<A, B> (
val p1: Recognizer<A>, val p2: Recognizer<B>
) : Recognizer<A>() {
    override fun invoke(p: Int): CPSResult<A> {
        val passedByp1: ArrayList<Pair<Int, A>> = ArrayList()
        val passedByp2: ArrayList<Pair<Int, B>> = ArrayList()
        val executed  : ArrayList<Pair<Int, A>> = ArrayList()
        return { k: K<A> ->
           p2(p)({ pos: Int, res: B ->
               val pair2p = Pair(pos, res)
               passedByp2.add(pair2p)
               passedByp1.forEach { r ->
                   val q = passedByp2.find {it.first == r.first}
                   if(q == null){
                       k(pos, r.second)
                       executed.add(Pair(pos, r.second))
                   }
                }
            })
            p1(p)({ pos: Int, res: A ->
                val pair1p = Pair(pos, res)
                passedByp1.add(pair1p)
                 k(pos, res)
            })
        }}}
\end{lstlisting}

\section{Апробация}
В данном разделе приведены результаты тестирования производительности парсер-комбинаторной библиотеки. Для тестирования были выбраны несколько грамматик. Эксперименты проводилось на машине со следующими характеристиками:
\begin{itemize}
     \item  OS  -- Ubuntu 16.04;
     \item  CPU -- Intel Core i5-4200M;
     \item  RAM -- 4GB.
\end{itemize}

 Первая грамматика сильно неоднозначная, содержащая леворекурсивные правила, реализует худший случай для анализатора.
\begin{lstlisting}[ frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Грамматика для языка $\{a^{*}\}$}, literate={->}{$\rightarrow$}{2}]
S -> SSS | SS | a
\end{lstlisting}

\pgfplotsset{WhaleCalf/.style = {red}}
\pgfplotsset{parserCombinators/.style = {blue}}

\begin{tikzpicture}[font=\small]
\begin{axis}[
 	title = Рис.2: Сравнение времени работы,
	xlabel = {Длина строки},
	ylabel = {Время разбора, мс.},
	xmin = 0, ymax = 4680
]
\legend{ 
    WhaleCalf,
    parserCombinators
};

\addplot[WhaleCalf] table {
	x     y
1 0.013
2 0.01
3 0.011
4 0.018
5 0.031
6 0.049
7 0.073
8 0.092
9 0.114
10 0.145
11 0.181
12 0.218
13 0.269
14 0.306
15 0.358
16 0.423
17 0.496
18 0.562
19 0.735
20 0.874
21 0.956
22 1.035
23 1.196
24 1.303
25 1.407
26 1.588
27 1.757
28 1.926
29 2.063
30 2.272
31 2.528
32 2.773
33 3.150
34 3.184
35 3.382
36 3.827
37 3.974
38 4.154
39 4.454
40 4.667
% 41 5.005
% 42 5.301
% 43 6.098
% 44 6.243
% 45 6.471
% 46 7.021
% 47 7.409
% 48 7.994
% 49 8.263
% 50 8.848
};

\addplot[parserCombinators] table {
	x     y
1     0.1467885555555556
2     0.519475
3     0.7699237777777778
4     0.6722894444444445
5     0.7785703333333333
6     0.719509111111111
7     1.0548891111111114
8     0.9587483333333334
9     1.636217666666667
10     1.5849111111111112
11     2.5421855555555553
12     6.034743222222223
13     8.343033
14     10.218517555555556
15     8.021728555555557
16     11.436654555555556
17     14.815570666666664
18     18.645544444444443
19     30.582576111111116
20     38.71770466666667
21     53.21479733333333
22     61.481628666666666
23     97.40201955555557
24     120.58717422222223
25     140.52813911111113
26     183.80796766666668
27     239.40063322222218
28     310.6426397777778
29     404.8557867777778
30     576.4985364444444
31     723.4561513333333
32     929.3584238888889
33     1162.9811624444444
34     1379.9422183333334
35     1761.1711207777778
36     2131.158415888889
37     2598.767933111111
38     3210.6734888888886
39     3944.221293555556
40     4680.549394222222
% 41     5788.453918444444
% 42     7057.305887777777
% 43     8434.018997444444
% 44     10477.304796444447
% 45     12430.76206488889
% 46     14600.36347422222
% 47     17442.277908555556
% 48     22288.710936555555
% 49     26218.650369111114
% 50     31266.917491888893
};
\end{axis}
\end{tikzpicture}

Результаты измерений представлены на рис.2. В библиотеке WhaleCalf реализовано несколько алгоритмов синтаксического анализа. Лучший результат демонстрирует алгоритм GLR, поэтому для сравнения производительности использовался он. Видно, что время работы алгоритма GLR растет значительно медленнее, чем время работы парсер-комбинаторов, с ростом длины входной строки.

Следующий эксперимент проводился на конъюнктивной грамматике, которая определяет требование declaration before use. Грамматика взята из работы \cite{okhotin2013conjunctive}. Результаты измерений представлены на рис.3. Видно, что решение, основанное на алгоритме GLR, быстрее парсер-комбинаторов.

\begin{lstlisting}[ frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Грамматика для языка $\{u_{1}...u_{n} | n \geq 0, \forall i \ u_{i} \in da^{*} \ or \ u_{i} = ca^{k} \ and \ u_{j} = da^{k} \ \forall j < i, \  k \geq 0\}$}, literate={->}{$\rightarrow$}{2} {e}{$\varepsilon$}{2}]

S -> SdA | ScA & EdB | e
A -> aA  | e
B -> aBa | E c
E -> EcA | EdA | e
\end{lstlisting}

\begin{tikzpicture}[font=\small]
\begin{axis}[
 	title = Рис.3: Сравнение времени работы,
	xlabel = {Длина строки},
	ylabel = {Время разбора, мс.},
	xmin = 0, ymax = 70
]
\legend{ 
    WhaleCalf,
    parserCombinators
};

\addplot[WhaleCalf] table {
	x     y
11 0.089
14 0.147
18 0.385
20 0.350
26 0.501
30 0.572
32 0.372
38 0.752
42 0.767
44 1.167
47 1.212
50 1.144
53 1.264
56 1.606
60 1.232
62 1.894
65 1.973
68 2.163
70 1.518
74 1.761
77 1.655
80 1.595
86 2.936
92 3.733
94 3.949
97 4.187
100 4.342
};

\addplot[parserCombinators] table {
	x     y
1     0.4628673333333333
2     0.5540354444444444
3     0.7079234444444445
4     0.8587408888888889
5     0.7730125555555555
6     1.6462317777777777
7     0.49815622222222217
8     0.5814115555555556
9     2.4074621111111107
10     2.2431968888888885
11     0.45204599999999995
12     0.8434487777777777
13     0.4728953333333334
14     0.48997744444444447
15     0.549250888888889
16     1.8580685555555558
17     0.7478501111111111
18     0.7008604444444444
19     1.2975633333333334
20     1.947107555555556
21     2.323931666666667
22     1.7482975555555553
23     1.7937134444444445
24     2.0465076666666664
25     2.6330674444444444
26     2.317769888888889
27     2.4125258888888887
28     2.1975258888888893
29     3.526575555555555
30     3.120240666666666
31     3.028660777777778
32     4.5070663333333325
33     3.7314388888888885
34     2.635454777777778
35     3.192737111111111
36     4.0294434444444445
37     3.631315222222222
38     3.3962945555555555
39     3.6075079999999997
40     3.8235200000000003
41     4.184627000000001
42     2.867902333333333
43     3.1068134444444446
44     4.8508059999999995
45     5.160292444444445
46     4.824212888888889
47     5.089932888888889
48     5.759478
49     13.156102111111112
50     6.480676111111111
51     7.324275777777777
52     5.199492666666667
53     5.3807587777777774
54     5.237726444444444
55     5.455311222222223
56     5.617577111111111
57     10.125115333333333
58     9.023506000000001
59     6.596706888888889
60     7.119133111111113
61     7.394988333333334
62     7.775678666666668
63     8.199235555555555
64     8.418771666666666
65     9.049349777777778
66     9.71119388888889
67     9.831141333333335
68     10.259596444444446
69     10.25650211111111
70     11.451496444444444
71     11.125072
72     12.774822333333333
73     12.089113888888889
74     13.903221333333335
75     14.18031888888889
76     15.17791811111111
77     14.614737555555555
78     15.312628222222223
79     15.686707333333333
80     16.85655311111111
81     16.914165777777775
82     17.660254555555557
83     17.72268
84     19.263018111111112
85     19.03671522222222
86     20.069770777777777
87     20.560021777777777
88     21.713791
89     22.358983999999996
90     23.157455
91     24.007724444444445
92     24.526497666666668
93     25.50756277777778
94     26.581510888888886
95     27.63483833333333
96     30.253949444444444
97     29.909227555555553
98     31.007197
99     31.987942999999998
100     33.590592111111114
};
\end{axis}
\end{tikzpicture}

Также тестирование проводилось на булевой грамматике для языка  $\{\omega \omega |\omega \in \{a, b\}^{*}\}$. Результаты представлены на Рис. 4. 

\begin{lstlisting}[ frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Булева рамматика для языка $\{\omega \omega |\omega \in \{a, b\}^{*}\}$}, literate={->}{$\rightarrow$}{2} {not}{$\neg$}{2} {e}{$\varepsilon$}{2}]

     S -> notAB & notBA & C 
     A -> XAX | a 
     B -> XBX | b  
     X -> a   | b
     C -> XXC | e  
       
\end{lstlisting}

\begin{tikzpicture}[font=\small]
\begin{axis}[
 	title = Рис.4: Время работы,
	xlabel = {Длина строки},
	ylabel = {Время разбора, мс.},
	xmin = 0, ymax = 1915
]
\legend{ 
    parserCombinators
};

\addplot[parserCombinators] table {
2     1.0640454444444445
4     0.9243794444444444
6     1.3389104444444444
8     1.1205922222222222
10     0.8095337777777778
12     1.178865111111111
14     3.094342333333334
16     1.8045623333333332
18     1.6222911111111111
20     1.550488111111111
22     1.522942888888889
24     4.998551222222222
26     4.640256888888889
28     5.056996222222222
30     3.175485777777778
32     5.738888111111112
34     4.830711
36     6.849439888888889
38     7.501666
40     9.477673666666666
42     7.722357333333333
44     10.485321444444445
46     18.494181
48     11.582935222222224
50     9.118546
52     8.93921011111111
54     5.874344111111111
56     12.492893777777779
58     8.801979888888889
60     9.111663444444446
62     7.589673333333334
64     8.870427666666666
66     23.89383488888889
68     8.839668888888887
70     6.516862999999999
72     8.611542666666667
74     13.53467411111111
76     9.615895888888888
78     7.977408666666666
80     9.778960333333332
82     12.55732688888889
84     10.445689111111111
86     26.288908222222222
88     12.40590811111111
90     11.208413222222223
92     12.886300666666665
94     12.341160888888888
96     12.933336444444445
98     15.313951333333332
100     18.366356777777774
102     17.494048555555555
104     24.683093
106     19.281464777777774
108     21.353682222222222
110     21.017543888888888
112     22.699374333333335
114     29.70909244444444
116     26.881248444444445
118     28.430285333333334
120     34.22939544444444
122     30.554415555555554
124     34.030142444444444
126     35.57865944444445
128     51.837688
130     38.65111255555556
132     45.491368
134     45.903743000000006
136     62.83477855555556
138     47.86215344444444
140     55.69601511111111
142     54.16467966666667
144     66.09276044444444
146     59.47050899999999
148     67.94486466666666
150     68.58248188888889
152     81.31949844444445
154     73.73505566666667
156     81.08263122222223
158     90.02323088888889
160     88.03938522222222
162     82.47442944444447
164     102.6590358888889
166     93.27847677777778
168     94.39794466666666
170     102.01755322222222
172     108.24406544444444
174     114.19381633333332
176     123.4673198888889
178     142.74972799999998
180     155.60029566666668
182     185.61289744444446
184     139.377708
186     163.7050121111111
188     166.79264722222223
190     179.64506466666666
192     180.38177622222221
194     217.32556855555558
196     185.24679555555556
198     233.4703951111111
200     220.9196571111111
202     243.76183077777782
204     250.67040933333334
206     303.5789477777778
208     275.80660066666667
210     294.00048766666663
212     340.01484211111114
214     271.413672
216     349.67304866666666
218     324.15739133333335
220     332.6829513333334
222     346.99941755555557
224     372.1571187777778
226     387.6247804444444
228     384.49884655555553
230     533.0489474444444
232     431.85771488888884
234     542.2939137777778
236     517.3117805555555
238     615.6938168888888
240     638.2851642222222
242     527.445243111111
244     621.9399882222223
246     779.1491805555556
248     769.8033214444445
250     820.1117765555556
252     793.4762202222222
254     892.5386601111111
256     982.576490777778
258     901.0619467777777
260     591.4458950000001
262     1058.1956089999999
264     875.6780616666667
266     943.8956463333335
268     1432.9378413333334
270     1038.2475274444444
272     1236.668703
274     1229.1496033333333
276     1313.69036
278     973.3905223333334
280     1263.8038556666668
282     1477.680575333333
284     1492.4521573333334
286     1813.8424021111111
288     1538.9724116666669
290     2167.629363888889
292     1457.6981267777778
294     2093.3257846666666
296     2019.4629592222223
298     1938.0090387777777
300     1914.6981726666668
};
\end{axis}
\end{tikzpicture}
 
Базовая структура псевдоузла (pseudoknot), элемента вторичной структуры РНК, может быть представлена в виде языка $L_{2}$ = $\{ \omega | \omega = [^{i} \ (^{j} \ ]^{i} \ )^{j}\}$, где пара скобок представляет собой пару оснований (base pair). Язык $L_{2}$ не является контекстно-свободным, однако он может быть представлен в виде пересечения языков $\{ \omega | \omega = [^{i} \ (^{*} \  ]^{i} \ )^{*}\}$ и $\{ \omega | \omega = [^{*} \ (^{j} \ ]^{*} \ )^{j}\}$. 

\begin{lstlisting}[ frame=top, frame=bottom , tabsize=2, basicstyle=\small, inputencoding=utf8x, caption={Конъюнктивная рамматика для языка $L_{2}$}, literate={->}{$\rightarrow$}{2} {eps} {$\varepsilon$} {2}]

  S  -> S1 & S5
  p1 -> [
  p2 -> ]
  p3 -> (
  p4 -> ) 
  S1 -> S2 S3
  S2 -> p1 S2 p2 | S4
  S4 -> p3 S4 | eps
  S3 -> p4 S3 | eps
  S5 -> S6 S7
  S7 -> p3 S7 p4 | S8
  S6 -> p1 S6 | eps
  S8 -> p2 S8 | eps
\end{lstlisting}

% \begin{table}[h]
% \begin{center}
%   \begin{tabular}{ ||c c||}
%     \hline \hline
%      Количество символов & Время, мс. \\ [0.5 ex]
%      \hline \hline
%      64	  &  0.010 \\\hline
%     128	  &  0.031 \\\hline
%     256	  &  0.136 \\\hline
%     512	  &  0.384 \\\hline
%     860	  &  5.613 \\\hline
%     1024  &	10.146 \\\hline 
%     1668  &	15.466 \\\hline
%     2048  &	20.901 \\\hline
%     2448  &	42.612 \\\hline
%     3000  &	78.301 \\\hline
%     \hline
%   \end{tabular}
% \end{center}
% \caption{Время анализа}
% \label{mistakes}
% \end{table}

\begin{tikzpicture}[font=\small]
\begin{axis}[
 	title = Рис.5: Время работы,
	xlabel = {Длина строки},
	ylabel = {Время разбора, мс.},
	xmin = 0, ymax = 28
]
\legend{ 
    parserCombinators
};
\addplot[parserCombinators] table {
8     0.0014854065555555554
48     0.008387210555555554
88     0.006238914666666668
128     0.014713604666666666
168     0.02221627788888889
208     0.03062123088888889
248     0.09475267799999999
288     0.21089444544444447
328     0.20804518566666666
368     0.4043343896666667
408     0.13108530944444446
448     0.6960183855555555
488     0.2510156087777778
528     0.44209866222222227
568     1.8214518848888888
608     1.0916717018888888
648     2.056361461222222
688     3.061255587666667
728     1.2357362213333334
768     3.3416755856666667
808     2.258288611222222
848     2.770524849888889
888     4.856858116888889
928     2.6329515574444446
968     4.313901428777777
1008     4.584217403555556
1048     4.135192818444444
1088     5.7436898394444444
1128     8.813338645555556
1168     8.522091676666669
1208     5.794862446888889
1248     7.078329769222222
1288     7.872143247777777
1328     7.558032206555552
1368     7.325445865888889
1408     12.84338571166667
1448     16.509911610888889
1488     16.20621580111111
1528     15.571542550444443
1568     21.401154465333335
1608     20.07510894522222
1648     15.956956504222225
1688     20.016370141666666
1728     16.221282566444447
1768     20.644998718
1808     16.113997420444445
1848     20.628701012999997
1888     22.04269102544444
1928     20.87910117222222
1968     24.099409569777777
2008     27.734409383555555
};
\end{axis}
\end{tikzpicture}

Результаты измерений представлены на Рис.5. Видно, что время работы растет достаточно быстро.

\section*{Заключение}
В ходе работы получены следующие результаты:
\begin{itemize}
    \item реализована парсер-комбинаторная библиотека с поддержкой булевых грамматик, в том числе содержащих леворекурсивные правила;
    \item проведена апробация библиотеки на примере контекстно-свободной грамматики, булевой грамматики и грамматики из биоинформатики;
    \item проведено сравнение с существующими решениями;
    \item результаты работы представлены на конференции "СПИСОК-2017".
\end{itemize}
Исходный код доступен в репозитории \cite{pc}, автор вел работу под учетной записью \textit{onewhl}.

В текущем виде библиотека не готова к промышленному использованию, поскольку необходимы оптимизации, способствующие повышению скорости работы парсер-комбинаторов.

%% \setmonofont[Mapping=tex-text]{CMU Typewriter Text}
%% \bibliographystyle{ugost2008ls}
%% \bibliography{coursework.bib}

\begin{thebibliography}{10}
\def\selectlanguageifdefined#1{
\expandafter\ifx\csname date#1\endcsname\relax
\else\selectlanguage{#1}\fi}
\providecommand*{\href}[2]{{\small #2}}
\providecommand*{\url}[1]{{\small #1}}
\providecommand*{\BibUrl}[1]{\url{#1}}
\providecommand{\BibAnnote}[1]{}
\providecommand*{\BibEmph}[1]{#1}
\ProvideTextCommandDefault{\cyrdash}{\iflanguage{russian}{\hbox
  to.8em{--\hss--}}{\textemdash}}
\providecommand*{\BibDash}{\ifdim\lastskip>0pt\unskip\nobreak\hskip.2em plus
  0.1em\fi
\cyrdash\hskip.2em plus 0.1em\ignorespaces}
\renewcommand{\newblock}{\ignorespaces}

\bibitem{okhotin2004boolean}
\selectlanguageifdefined{english}
\BibEmph{Alexander~Okhotin}. Boolean grammars~// \BibEmph{Information and
  Computation}. \BibDash
\newblock 2004. \BibDash
\newblock Vol. 194, no.~1. \BibDash
\newblock P.~19--48.

\bibitem{okhotin2013conjunctive}
\selectlanguageifdefined{english}
\BibEmph{Alexander~Okhotin}. Conjunctive and Boolean grammars: the true general
  case of the context-free grammars~// \BibEmph{Computer Science Review}.
  \BibDash
\newblock 2013. \BibDash
\newblock Vol.~9. \BibDash
\newblock P.~27--59.

\bibitem{izmaylova2016practical}
\selectlanguageifdefined{english}
\BibEmph{Anastasia~Izmaylova, Ali~Afroozeh, Tijs~van der~Storm}. Practical,
  general parser combinators~// Proceedings of the 2016 ACM SIGPLAN Workshop on
  Partial Evaluation and Program Manipulation~/ ACM. \BibDash
\newblock 2016. \BibDash
\newblock P.~1--12.

\bibitem{spiewak2010generalized}
\selectlanguageifdefined{english}
\BibEmph{Daniel~Spiewak}. Generalized Parser Combinators. \BibDash
\newblock 2010.

\bibitem{hutton1996monadic}
\selectlanguageifdefined{english}
\BibEmph{Graham~Hutton, Erik~Meijer}. Monadic parser combinators. \BibDash
\newblock 1996.

\bibitem{sippl1999biological}
\selectlanguageifdefined{english}
\BibEmph{Manfred~J~Sippl}. Biological sequence analysis. Probabilistic models
  of proteins and nucleic acids, edited by R. Durbin, S. Eddy, A. Krogh, and G.
  Mitchinson. 1998.~// \BibEmph{Protein Science}. \BibDash
\newblock 1999. \BibDash
\newblock Vol.~8, no.~3. \BibDash
\newblock P.~695--695.

\bibitem{johnson1995memoization}
\selectlanguageifdefined{english}
\BibEmph{Mark~Johnson}. Memoization in top-down parsing~//
  \BibEmph{Computational Linguistics}. \BibDash
\newblock 1995. \BibDash
\newblock Vol.~21, no.~3. \BibDash
\newblock P.~405--417.

\bibitem{chomsky1956three}
\selectlanguageifdefined{english}
\BibEmph{Noam~Chomsky}. Three models for the description of language~//
  \BibEmph{IRE Transactions on information theory}. \BibDash
\newblock 1956. \BibDash
\newblock Vol.~2, no.~3. \BibDash
\newblock P.~113--124.

\bibitem{norvig1991techniques}
\selectlanguageifdefined{english}
\BibEmph{Peter~Norvig}. Techniques for automatic memoization with applications
  to context-free parsing~// \BibEmph{Computational Linguistics}. \BibDash
\newblock 1991. \BibDash
\newblock Vol.~17, no.~1. \BibDash
\newblock P.~91--98.

\bibitem{pc}
\selectlanguageifdefined{russian}
parserCombinators [Электронный ресурс]. \BibDash
\newblock {Режим доступа}:
  \BibUrl{https://github.com/anlun/parserCombinators/} ({дата
  обращения}: 19.05.2017).

\end{thebibliography}
