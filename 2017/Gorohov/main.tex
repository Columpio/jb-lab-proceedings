%\documentclass[14pt]{matmex-diploma-custom}
%\hyphenation{Ge-ne-ra-lised}
\newtheorem{mydef}{Определение}
%\tolerance=1
\emergencystretch=\maxdimen
%\hyphenpenalty=10000
%\hbadness=10000



\title{Поддержка расширенных контекстно-свободных грамматик 
	в алгоритме синтаксического анализа Generalised LL}

\titlerunning{Поддержка расширенных контекстно-свободных грамматик 
	в GLL}

\author{Горохов Артем Владимирович}

\authorrunning{А.В.Горохов}

\tocauthor{А.В.Горохов}
\institute{Санкт-Петербургский государственный университет\\
	\email{gorohov.art@gmail.com}}

\maketitle

\begin{abstract}
	Для автоматизации разработки синтаксических анализаторов часто используют генераторы, строящие анализаторы на основе спецификации языка.
	Обычно спецификация описывается неоднозначной грамматикой в расширенной форме Бэкуса-Наура (EBNF), которую не могут обрабатывать большинство инструментов без преобразования
	к форме Бэкуса-Наура (BNF).	Существующие подходы анализа EBNF без преобразования к BNF не способны обрабатывать неоднозначные грамматики. С другой стороны, алгоритм Generalized LL (GLL) допускает произвольные контекстно-свободные грамматики и достигает	высокой производительности, но не способен обрабатывать EBNF грамматики. 
	В данной работе описана модификация GLL алгоритма для обработки расширенных контекстно-свободных грамматик,
	эта форма родственна EBNF. Так же показано, что предложенный подход повышает производительность анализа по сравнению с алгоритмами использующими преобразование грамматик.
\end{abstract}


\section*{Введение}

Статический анализ --- это анализ программного кода без его исполнения. Он производится после синтаксического анализа на основе грамматики,
описывающей синтаксис языка.
%над структурным представлением кода, получаемым в результате синтаксического анализа. 
Общеупотребимый способ описания синтаксиса языков программирования --- грамматики в расширенной форме Бэкуса-Наура (EBNF)~\cite{EBNFISO}.
С одной стороны, эта форма проста для понимания людей, с другой, достаточно формальна и допускает автоматизированное создание синтаксических анализаторов.
Примером могут служить спецификации языков $C$, $C++$, $Java$ и т.д. 

Проблема в том, что существующие генераторы анализаторов, такие как ANTLR~\cite{ANTLRa}, Bison~\cite{Bison}, преобразуют грамматики в форму EBNF
для упрощения их структуры. В результате этого, представление кода строится на основе грамматики, отличной от заданной,
что затрудняет обработку результатов анализа. С другой стороны, производительность таких алгоритмов анализа,
как Generalised LL (GLL)~\cite{scott2010gll}
зависит от структуры грамматики, а её упрощение часто ведёт к избыточности представления, что отрицательно сказывается на производительности.

Алгоритм GLL показывает высокую производительность и способен работать с неоднозначными грамматиками. 
Предполагается, что поддержка в нём EBNF или родственных этой форме расширенных контекстно-свободных грамматик,
увеличит производительность анализа для некоторых грамматик.

% todo хочется дополнить
В данной работе предложен алгоритм синтаксического анализа, основанный на Generalised LL, для работы с расширенными
контекстно-свободными грамматиками без преобразований.
Показанно, что для некоторых грамматик алгоритм более производителен, чем существующие вариации GLL.
В разделе 1 представлен обзор предметной области и литературы. Далее в разделе 2 представлены необходимые изменения в Generalised LL алгоритме
и сопутствующих структурах данных. В разделе 3 описаны пути применения описанного алгоритма в задаче анализа регулярных множеств.
Эксперементальное сравнение полученного алгоритма с современными модификациями Generalised LL содержится в разделе 4.

\section{Обзор предметной области}
Заметим, что EBNF 
является стандартизированной формой для \textit{расширенных контекстно-свободных грамматик}.

\begin{mydef}
	Расширенная контекстно-свободная грамматика (ECFG)~\cite{ECFG} --- это кортеж $(N, \Sigma, P, S)$,
	где N и $\Sigma$ конечные множества нетерминалов и терминалов соответственно, 
	$S\in N$ является стартовым символом, а P (продукция) является отображением из N в
	регулярное выражение над алфавитом $N \cup \Sigma$.    
\end{mydef}

%ECFG широко используется в качестве входного формата для генераторов синтаксических анализаторов, 
%но классические алгоритмы синтаксического анализа часто требуют форму Бэкуса-Наура (BNF),
%в продукциях которой допускаются лишь последовательности из терминалов и нетерминалов. Таким образом 
%для работы генераторов анализаторов требуется преобразование в BNF.
%Возможно преобразование ECFG в BNF~\cite{ELL}, но оно приводит к увеличению
%размера грамматики и изменению её структуры: при трансформации добавляются новые
%нетерминалы. В результате синтаксический анализатор строит дерево вывода относительно
%преобразованной грамматики, и разработчику языка сложнее отлаживать грамматику 
%и использовать результат синтаксического анализа. Кроме того, увеличение размера грамматики 
%отрицательно сказывается на производительности анализа.

Существует широкий спектр методов анализа и алгоритмов~\cite{AttributedELL,ELRR,
	ECFGparsing,ELLParser,ELL,ECFG,ELALR,ELRParsing}, предназначенных для обработки
ECFG. Детальный обзор результатов и задач в этой области представлены в работе~\cite{ECFG}.
Следует отметить, что большинство алгоритмов основано на методах
LL-анализа~\cite{ELLParser,AttributedELL,PredictiveECFG} и LR-анализа~\cite{ELRParsing,ELALR,ELRR},
но они работают только с ограниченными подклассами расширенных контекстно-свободных грамматик ---
LL(k), LR(k). Таким образом, нет решения для обработки произвольных (в том числе неоднозначных) ECFG-грамматик.

ECFG-грамматики широко используется в качестве входного формата для генераторов синтаксических анализаторов, 
но классические алгоритмы синтаксического анализа часто требуют форму Бэкуса-Наура (BNF),
в продукциях которой допускаются лишь последовательности из терминалов и нетерминалов.
Возможно преобразование грамматик ECFG в форму BNF \cite{ELL}, но оно приводит к увеличению
размера грамматики и изменению её структуры: при трансформации добавляются новые
нетерминалы. В результате синтаксический анализатор строит дерево вывода относительно
преобразованной грамматики, что затрудняет обработку результата анализа.

В настоящее время алгоритмы на основе LL(1)-анализа представляются
наиболее практичными и обеспечивают лучшую диагностику ошибок по сравнению с LR-анализом, так как являются низходящими. 
Но некоторые грамматики не являются LL(k) (для любого k) и не могут быть использованы в LL(k) анализаторах.
Другие проблемы для инструментов на основе LL --- леворекурсивные грамматики и неоднозначности в грамматике, 
которые, вместе с предыдущим недостатком, усложняют создание анализаторов. 
Алгоритм Generalised LL, предложенный в~\cite{scott2010gll}, решает 
все эти проблемы: он обрабатывает произвольные CFG, в том числе неоднозначные и леворекурсивные.
В общем случае временная и пространственная сложность GLL зависит кубически от 
размера входа. А для LL(1) грамматик, он демонстрирует линейную временную и
пространственную сложность. Но он, как и другие современные алгоритмы, не допускает использования ECFG 
без предварительного преобразования к форме BNF.

Для увеличения производительности Generalised LL-алгоритма, была предложена поддержка 
лево-факторизованных грамматик в нём~\cite{scott2016structuring}.
Алгоритм GLL обрабатывает все возможные ветви разбора строки по заданной грамматике, 
эти ветви описываются так называемыми дескрипторами, которые состоят из позиций в грамматике и во входе,
корня построенного леса разбора и текущего узла стека. Из этого следует, что для уменьшения времени анализа и количества используемой памяти
можно снизить количество дескрипторов для обработки. Один из путей для достижения этого --- 
уменьшение размера грамматики (снижение количества различных позиций в ней).
Этого можно достичь факторизацией грамматики. Пример факторизации показан на рис.~\ref{fig:ExampleOfFactorization}:
из грамматики $G_0$ в процессе факторизации получена грамматика $G_0'$.
Этот пример рассмотрен в работе~\cite{scott2016structuring}, и доказано, что для некоторых грамматик факторизация 
существенно увеличивает производительность алгоритма GLL.
\begin{figure}
	\centering
	\subfloat[Исходная грамматика $G_0$]{
		$
		\begin{array}{rl}
		S::= a\ a\ b\ c\ d \ | \ a\ a\ c\ d \ | \ a\ a\ c\ e |\ a\ a
		\end{array}
		$
	}
	~
	\subfloat[Факторизованная грамматика $G_0'$]{
		$
		\begin{array}{rl}
		S::= a\ a\ ( b\ c\ d\ |\ c\ ( d\ |\ e )\ |\ \varepsilon \ )
		\end{array}
		$
	}
	\caption{Пример факторизации грамматики}
	\label{fig:ExampleOfFactorization}
\end{figure}

Одно из возможных применений обобщённого синтаксического анализа --- синтаксический анализ регулярных множеств.
Синтаксическим анализом регулярных множеств называют анализ строк, заданных всеми возможными путями в конечном автомате.
Такая задача возникает в различных областях одна из которых --- биоинформатика. В результате экспериментов 
получают данные о геномах организмов, которые представлены строками в конечном автомате (геномы это строки над алфавитом $\{A;C; G; T\}$).
Этот автомат называется метагеномной сборкой.

Существует множество подходов к анализу и идентификации геномов. Один из них --- поиск и сравнение участков таких структур как
16s рРНК, тРНК, так как по ним можно достаточно точно классифицировать организм, которому они принадлежат.
Существуют такие инструменты, как REAGO~\cite{reago} и HMMER~\cite{hmmer}, использующие скрытые цепи Маркова для поиска, 
Infernal~\cite{Infernal}, использующий ковариационные модели. Но они работают лишь с линейными цепочками генома ---
не объединёнными в конечный автомат, такое представление требует большого количества памяти и неэффективно.
С другой стороны, инструмент Xander~\cite{xander} использует композицию скрытых моделей Маркова и метагеномных сборок.
Изъян данного инструмента в существенно более низкой точности результата в сравнении с инструментами, использующими ковариационные модели.

Другой подход разрабатывается в лаборатории JetBrains СПбГУ.
Поиск производится непосредственно в метагеномной сборке по таким структурам как тРНК, 16s рРНК.
Эти структуры имеют некоторые общие свойства в строении, которые могут быть описаны
контекстно-свободной грамматикой~\cite{Anderson2013a}.
Таким образом, можно использовать синтаксический анализ регулярных множеств для поиска.
Этот подход описан в работе~\cite{ragozina}, основан на алгоритме синтаксического анализа Generalised LL и 
был реализован в рамках проекта YaccConstructor~\cite{YaccConstructor}. В нашей работе 
будут использоваться результаты и данные из работы~\cite{ragozina} для сравнения производительности полученного алгоритма.

\section{Использование Generalised LL для обработки ECFG}

В этом разделе описываются структуры и методы необходимые для использования расширенных контекстно-свободных грамматик 
в алгоритме синтаксического анализа Generalised LL, а так же необходимые изменения в алгоритме анализа.

\subsection{Представление ECFG}

Представление ECFG, наиболее подходящее для синтаксического анализа --- рекурсивные автоматы
(Recursive Automaton (RA)~\cite{tellier2006learning}.
\begin{mydef}
	Рекурсивный автомат $R$ это кортеж $(\Sigma, Q, S, F, \delta)$, где $\Sigma$
	--- конечное множество терминалов, $Q$ - конечное множество состояний, $S \in Q$ 
	--- начальное состояние, $F \subseteq Q$ --- множество конечных состояний,
	$\delta : Q \times (\Sigma \cup Q) \to Q$ --- функция перехода.
\end{mydef}
В рамках этой работы единственное различие между рекурсивным автоматом и общеизвестным
конечным автоматом (FSA) состоит в том, что переходы в RA обозначаются либо терминалом ($\Sigma$),
либо состоянием автомата ($Q$). Далее будем называть переходы помеченные элементами из
$Q$ \textit{нетерминальными переходами}, а терминалами --- \textit{терминальными переходами}.
Нетерминальный переход в состояние $q$ подразумевают построение вывода для некоторой подстроки начиная с текущей позиции во входе
по этому нетерминалу и последующий разбор оставшейся подстроки начиная с состояния $q$.

Заметим, что позиции грамматики эквивалентны состояниям автомата, которые 
строятся из правых частей продукций грамматики. Правые части продукций ECFG являются регулярными
выражениями над объединенным алфавитом терминалов и нетерминалов, поэтому построить по ним автомат можно использую общеизвестные алгоритмы.
Следующий алгоритма строит RA с минимальным числом состояний для заданной ECFG.
\begin{itemize}
	\item Построить конечный автомат, используя метод Томпсона~\cite{Thompson:1968:PTR:363347.363387} для правых
	частей продукций.
	\item Создать ассоциативный массив $M$ из каждого нетерминала в соответствующее начальное состояние автомата.
	Этот массив должен оставаться консистентным на протяжение всех следующих шагов.
	\item Преобразовать автоматы из предыдущего шага в детерминированные без 
	$\varepsilon$-переходов используя алгоритм, описанный в~\cite{aho1974design}.
	\item Минимизировать детерминированный автомат, используя, например, алгоритм
	Джона Хопкрофта~\cite{hopcroft1971n}.
	\item Заменить нетерминальные переходы переходами по, стартовым состояниям автоматов,
	соответствующим данным нетерминалам, используя массив $M$. Результат 
	этого шага --- искомый рекурсивный автомат. Также используем $M$
	для определения функции $\Delta : Q \to N$ где $N$ --- имя нетерминала.
\end{itemize}
Пример преобразования ECFG в RA представлен на рис.~\ref{fig:fig1}, где состояние
0 --- начальное состояние полученного RA.
\begin{figure}
	\centering
	\subfloat[Грамматика $G_1$]{
		$
		\begin{array}[b]{rl}
		S ::= a^{+} S\ b? \ | \ c \ \ \ 
		\end{array}
		$
		\label{fig:grammarG0}
	}
	~
	\subfloat[Конечный автомат для $G_1$]{
		\includegraphics[scale=.6]{./Gorohov/pictures/G0initialAutomaton.pdf}
		\label{fig:initialAutomatonsForG0}
	}
	~
	\subfloat[Рекурсивный автомат $R_1$ для $G_1$]{
		\includegraphics[scale=.6]{./Gorohov/pictures/G0minimizedAutomaton.pdf}
		\label{fig:RAForG0}
	}
	\caption{Преобразование грамматики в рекурсивный автомат}
	\label{fig:fig1}
\end{figure}

\subsection{Лес разбора для ECFG}
Результатом синтаксического анализа является структурное представление 
входа --- дерево или лес разбора в случае нескольких вариантов деревьев.
Для начала, определим дерево вывода для рекурсивного автомата: 
это дерево, корень которого помечен начальным состоянием, листья терминалы или $\varepsilon$,
а внутренние узлы нетерминалы N и их
дети образуют последовательность заданную путём в автомате, который начинается в 
состоянии $q_i$, где $ \Delta(q_i) = N $. Введём это определение более формально.

\begin{mydef}
	
	Дерево вывода последовательности $\alpha$ для рекурсивного автомата $R=(\Sigma, Q, S, F, \delta)$ это дерево со следующими свойствами:
	
	\begin{itemize}
		\item корень помечен $\Delta(S)$;
		\item листья --- терминалы $a\in (\Sigma \cup \varepsilon)$;
		\item остальные узлы --- нетерминалы $A\in \Delta(Q)$;
		\item у узла с меткой $N_i = \Delta(q_i)$ существует:
		\begin{itemize}
			\item 
			дети $l_0 \dots l_n (l_i \in \Sigma \cup \Delta(Q))$ тогда и только тогда,
			когда существует путь $p$ в $R$, $p = q_i \xrightarrow[]{l_0} q_{i+1} \xrightarrow[]{l_1} \dots \xrightarrow{l_n} q_m$, где
			$q_m \in F$, $l_i = 
			\left\{
			\begin{matrix}
			k_i, \text{ if } k_i \in \Sigma,\\
			\Delta(k_i), \text{ if } k_i \in Q,
			\end{matrix}
			\right.
			$
			\item только один ребенок помеченный $\varepsilon$ тогда и только тогда,
			когда $ q_i \in F $.
		\end{itemize}
	\end{itemize}
\end{mydef}
Для произвольных грамматик RA может быть неоднозначным с точки зрения допустимых путей,
поэтому можно получить несколько деревьев разбора для одной входной строки.
Shared Packed Parse Forest (SPPF)~\cite{SPPFa} может использоваться как компактное
представление всех возможных деревьев разбора. Будем использовать бинаризованную версию SPPF,
предложенную в~\cite{brnglr}, для уменьшения потребления памяти и достижения кубической
наихудшей временной и пространственной сложности. Бинаризованный SPPF может использоваться
в GLL~\cite{scott2013gll} и содержит следующие типы узлов (здесь i и j --- начало и конец выведенной подстроки во входной строке):

\begin{itemize}
	\item упакованные узлы вида $(S, k)$, где $S$ состояние автомата, k --- начало выведенной
	подстроки правого ребёнка; у упакованных узлов обязательно существует правый ребёнок ---
	символьный узел, и опциональный левый --- символьный или промежуточный узел;
	\item символьный узел помечен $(X, i, j)$ где $X \in \Sigma \cup \Delta(Q) \cup \{\varepsilon\}$;
	терминальные символьные узлы ($X \in \Sigma \cup \{\varepsilon\}$) --- листья;
	нетерминальные символьные узлы ($X \in \Delta(Q)$) могут иметь несколько упакованных детей;
	\item промежуточные узлы помечены $ (S, i, j) $, где $S$ состояние в автомате, могут иметь несколько упакованных детей.
\end{itemize}
Дети символьных и промежуточных узлов --- упакованные. Различные упакованные дети --- различные варианты поддеревьев.
Если у узла или его потомков более одного упакованного ребёнка, то он содержит несколько вариантов 
разбора для подстроки. Промежуточные и упакованные узлы необходимы для бинаризации SPPF, что обеспечивает большее переиспользование узлов.
Так, деревья, представленные на рис.~\ref{fig:Gtrees}, объединяются в SPPF показанный на рис.~\ref{fig:GSPPF}.
\begin{figure}
	\centering
	$
	\begin{array}[b]{rl}
	S ::= S\ S\ | \ c \ \ \ 
	\end{array}
	$
	\caption{Грамматика $G_0$}
	\label{fig:fig0}
\end{figure}
\begin{figure}[ht]   
	\centering
	\subfloat[Возможные деревья вывода]{
		\includegraphics[scale=.3]{./Gorohov/pictures/Gtrees.pdf}
		\label{fig:Gtrees}
	}
	~
	\subfloat[SPPF]{
		\includegraphics[scale=.3]{./Gorohov/pictures/GSPPF.pdf}
		\label{fig:GSPPF}
	}
	\caption{Пример для входа $ ccc $ и грамматики $G_0$}
	\label{fig:fig01}
\end{figure}
Опишем модификации исходных функций построения SPPF.
Функция \textbf{getNodeT$ (x, i) $}, которая создает терминальные узлы, 
повторно используется без каких-либо модификаций из базового алгоритма.
Чтобы обрабатывать недетерминизм в состояниях, определим функцию 
\textbf{getNodes}, которая проверяет, является ли следующее состояние RA финальным
и в этом случае строит нетерминальный узел в дополнение к промежуточному.
Она использует изменённую функцию \textbf{getNodeP}: вместо позиции в грамматики он 
принимает в качестве входных данных отдельно состояние RA и символ для нового узла SPPF:
текущий нетерминал или следующее состояние RA.

\input{./Gorohov/getNodes.tex}
\input{./Gorohov/getNodeP.tex}

Рассмотрим пример SPPF для ECFG $ G_1 $, показанные на рис.~\ref{fig:grammarG0}.
Эта грамматика содержит конструкции (условное вхождение (?) и повторение (+)),
которые должны быть преобразованы с использованием дополнительных нетерминалов 
для создания обычного GLL-анализатора.
Предложенный генератор строит рекурсивный автомат $ R_1 $~(рис.~\ref{fig:RAForG0})
и анализатор для него. Возможные деревья ввода последовательности $ aacb $ показаны 
на рис.~\ref{fig:treesForG0}. SPPF, созданный синтаксическим анализатором~(рис.~\ref{fig:SPPFForG0}),
содержит в себе все три дерева.

\begin{figure}[ht]   
	\centering
	\subfloat[Возможные деревья вывода]{
		\includegraphics[scale=.4]{./Gorohov/pictures/G0trees.pdf}
		\label{fig:treesForG0}
	}
	~
	\subfloat[SPPF]{
		\includegraphics[scale=.4]{./Gorohov/pictures/G0SPPFwithPackedNodes.pdf}
		\label{fig:SPPFForG0}
	}
	\caption{Пример для входа $ aacb $ и автомата $R_1$}
	\label{fig:fig2}
\end{figure}

\subsection{Алгоритм построения леса разбора для ECFG}
В этом разделе описываются изменения в управляющих функциях базового алгоритма 
Generalised LL, необходимые для обработки ECFG. Основной цикл 
представленного алгоритма аналогичен базовому
GLL: на каждом шаге основная функция \textbf{parse} извлекает из очереди так называемый дескриптор
$R$ --- кортеж описывающий текущую ветку разбора. Пусть текущий дескриптор ($C_S, C_U, i, C_N$),
где $C_S$ --- состояние RA, $C_U$ --- узел GSS, i --- позицию во входной строке 
$\omega$, $C_N$ --- узел SPPF. В ходе обработки дескриптора могут возникнуть следующие
не исключающие друг друга ситуации.
\begin{itemize} 
	\item $C_S$ --- финальное состояние. Это возможно только если $C_S$
	--- стартовое состояние текущего нетерминала. Следует построить нетерминальный
	узел с ребёнком $(\varepsilon, i, i)$ и вызвать функцию \textbf{pop}, так как
	разбор нетерминала окончен.
	
	\item Существует терминальный переход $C_S \xrightarrow[]{\omega.[i]} q$.
	Во-первых, построить терминальный узел $ t = (\omega.[i], i, i+1) $, далее 
	вызвать функцию \textbf{getNodes} чтобы построить родителя для $ C_N $ и $ t $. 
	Функция \textbf{getNodes} возвращает кортеж $ (y, N) $, где $N$ --- опциональный
	нетерминальный узел. Создать дескриптор $ (q, C_U, i+1, y) $ и, если
	в $q$ ведёт несколько переходов, вызвать функцию \textbf{add} для этого дескриптора.
	Иначе поместить его в очередь вне зависимости от того был ли он создан до этого. 
	Если $ N \neq \$$,
	вызвать функцию \textbf{pop} для этого узла, состояния $ q $ и позиции во
	входе $ i + 1 $.
	
	\item Существуют нетерминальные переходы из $C_S$.
	Это значит, что следует начать разбор нового нетерминала, поэтому должен быть
	создан новый узел GSS, если такового ещё нет. Для этого нужно вызвать функцию
	\textbf{create} для каждого такого перехода. Она осуществляет необходимые
	операции с GSS и проверяет наличие узла GSS для текущих нетерминала и 
	позиции во входе.
\end{itemize}
Псевдокод для необходимых функций представлен ниже.

Функция \textbf{add} помещает в очередь дескриптор, если он не был создан до этого; эта функция не изменилась.
\input{./Gorohov/create.tex}

\input{./Gorohov/pop.tex}

%\textbf{Pop} function is called when we reach final state. It queues descriptors for all outgoing edges from current GSS node.

\input{./Gorohov/parse.tex}




\section{Синтаксический анализ регулярных множеств}

Описанный в данной работе алгоритм можно применять для анализа регулярных множеств.
При работе с конечным автоматом в качестве входных данных необходимо обрабатывать все переходы из текущей позиции (состояния) в автомате.
Так, основная функция приобретает следующий вид:
\input{./Gorohov/parseReg.tex}
Позициями во входе для автомата становятся номера состояний и обрабатываются все исходящие переходы во входе. Кроме того,    
Функция \textbf{add} вызывается при обработке терминального перехода всегда, чтобы поддержать возможные циклы во входе.
Например, для грамматики $S ::= a*$ и входного автомата на рис.~\ref{graphEx}
дескриптор будет создаваться бесконечно, если не добавить его в множество созданных, и алгоритм не остановится.
Данное изменение не меняет теоретическую сложность алгоритма, но может сказаться на производительности в худшую сторону.
Поэтому этот подход можно применять лишь только в случае присутствия циклов во ходе, иначе вызывать функцию \textbf{add}
только при наличии нескольких входящих переходов в текущее состояние.

\begin{figure}%[ht]   
	\centering
	\includegraphics[scale=.5]{./Gorohov/pictures/graphEx.pdf}
	\caption{Пример входа для грамматики $S ::= a^*$.}
	\label{graphEx}
\end{figure}

\section{Эксперименты}
В работе~\cite{scott2016structuring}
было проведено экспериментальное сравнение алгоритма для факторизованных грамматик (Factorised GLL, FGLL) и базового GLL-алгоритма,
продемонстрировавшее, что FGLL показывает большую производительность для грамматик в форме Бэкуса-Наура, которые могут быть факторизованы.
Предполагается, что предложенная в данной работе версия алгоритма
продемонстрирует большую производительность, чем FGLL, для грамматик, имеющих эквивалентные позиции для алгоритма минимизации автомата,
но различные после факторизации. Автомат, построенный для грамматики, в которой есть эквивалентные позиции, для которых алгоритм создаёт большое количество дескрипторов,
объединит данные позиции, сократив тем самым множество создаваемых дескрипторов,
что в свою очередь увеличит производительность. Примером такой ситуации может служить грамматика 
$G_2$~(рис.~\ref{fig:grammarG1}), так как она содержит длинные последовательности 
в альтернативах, которые не сливаются при факторизации, но эквивалентны для алгоритма минимизации автомата.
Рекурсивный автомат построенный для этой грамматики показан на рис.~\ref{fig:automatonForG1}.

\begin{figure}[ht]   
	\centering
	\subfloat[Грамматика $G_2$]{
		$
		\begin{array}{rl}
		S ::=& K\ (K\ K\ K\ K\ K \ |\ a\ K\ K\ K\ K) \\
		K ::=& S\ K\ |\ a\ K\ |\ a \\
		\end{array}
		$
		\label{fig:grammarG1}
	}
	
	\subfloat[Рекурсивный автомат для грамматики $G_2$]{
		\includegraphics[scale=.5]{./Gorohov/pictures/G1automaton.pdf}
		\label{fig:automatonForG1}
	}
	\caption{Грамматика $G_2$ и RA для неё}
\end{figure}

Эксперименты проводились на входах различной длины, результаты приведены на рис.~\ref{expPlots}.
Точные данные для входа $a^{450}$ показаны в таблице~\ref{expTable}.

Для экспериментов использовался ПК со следующими характеристиками: Microsoft Windows 10 Pro x64, Intel(R) Core(TM) i7-4790 
CPU @ 3.60GHz, 3601 Mhz, 4 Cores, 4 Logical Processors, 16 GB.

\input{./Gorohov/performancePlots.tex}

\begin{table}[ht]   
	\begin{center}
		\begin{tabular}{ | c | c | c | c | c | c | c |  }
			\hline
			& \rotatebox[origin=c]{90}{Время}
			& \rotatebox[origin=c]{90}{Дескрипторы} &
			\rotatebox[origin=c]{90}{Рёбра GSS} &
			\rotatebox[origin=c]{90}{Узлы GSS} &
			\rotatebox[origin=c]{90}{Узлы SPPF} &
			\rotatebox[origin=c]{90}{Память, Мб} \\ \hline
			FGLL & 10 мин. 13 с.  & 1104116        & 1004882      & 902        & 195 млн. &  11818 \\ \hline 
			RA       & 5 мин. 51 с.  & 803281        & 603472      & 902        & 120 млн. & 8026  \\ \hline \hline
			Ratio   &  43$\%$       & 28$\%$     & 40 $\%$    &  0 $\%$ &  39 $\%$ &  33 $\%$ \\ \hline
		\end{tabular}
	\end{center}
	\caption{Результаты экспериментов для входа $a^{450}$}
	\label{expTable}
\end{table}

Результаты данных экспериментов поддерживают предположение о том, что на некоторых грамматиках 
предложенный подход показывает результаты лучше FGLL.
Для этого рекурсивного автомата анализатор создаёт меньше дескрипторов, чем для грамматики, так как 
цепочки нетерминалов $K$ в альтернативах представлены единственным путём в автомате. Эта особенность ведёт к снижению количества 
узлов SPPF и размера GSS.
В среднем, с грамматикой $G_2$ версия с минимизированными автоматами работает на $43\%$ быстрее,
использует на $28\%$ меньше дескрипторов, на $40\%$ меньше рёбер GSS, создаёт на $39\%$ меньше узлов SPPF
и использует на $33\%$ меньше памяти.

Было проведено экспериментальное сравнение разработанного алгоритма GLL с
существующим в проекте YaccConstructor (основан на оригинальном алгоритме Generalised LL) в задаче поиска 16s рРНК в метагеномной сборке.
Длинные рёбра сборки были предварительно отфильтрованы с помощью инструмента Infernal.
В результате фильтрации сборка разбивается на компоненты, которые можно анализировать независимо друг от
друга. Тем не менее, предложенный ранее алгоритм не позволяет обработать некоторые компоненты, поэтому сравнение проводилось
на остальных: 10 компонент с 400-100 состояний и переходов и 1118 компонент с менее чем 100 состояний и переходов.
Результаты сравнения приведены в таблице~\ref{expTable1} и показывают, что при работе с метагеномными сборками новый
алгоритм, в среднем, использует на 65\% меньше памяти и работает на 45\% быстрее базового GLL. Сравнение с FGLL
показывает на 4\% меньшее использование памяти новым алгоритмом и на 10\% меньшее время работы.

\begin{table}
	\begin{center}
		\begin{tabular}{ | c | c | c | c | c | c |}
			\hline
			& &\multicolumn{2}{c|}{GSS} & & \\
			\cline{3-4}
			& Деск-ры & Рёбра   & Узлы   & Память& Время   \\ \hline
			GLL               &  802млн &  414млн & 339млн  & 20Гб & 52 мин. 43 с.  \\ \hline
			FGLL        &  382млн &  187млн & 134млн & 7Гб & 29 мин. 27 с.  \\ \hline
			RA                &  362млн &  190млн & 134млн & 6,8Гб & 26 мин. 34 с.  \\ \hline %\hline
			%Ratio   &  9$\%$       & 13$\%$     & 12 $\%$    &  3 $\%$  & 14 $\%$\\ \hline
		\end{tabular}
		\caption{Результаты экспериментов с метагеномной сборкой}
		\label{expTable1}
	\end{center}
\end{table}

\section*{Заключение}
В рамках данной работы была разработана и реализована модификация алгоритма GLL,
работающая с расширенными контекстно-свободными грамматиками. Показано, что полученный
алгоритм повышает производительность поиска структур, заданных с помощью контекстно-свободной
грамматики в метагеномных сборках. Описанный алгоритм и генератор синтаксических анализаторов реализованы
в расках проекта YaccConstructor на языке программирования F\#.
Исходный код доступен в репозитории проекта:~\url{https://github.com/YaccConstructor/YaccConstructor}.

Одним из методов для описания семантики языка являются атрибутные грамматики, но они не поддержаны в описанном алгоритме.
Опубликовано несколько работ о подклассе атрибутных ECFG (например~\cite{AttributedELL}), тем не менее нет общего решения для произвольных ECFG.
Таким образом, поддержка атрибутных расширенных контекстно-свободных грамматик и подсчёт семантики может быть дальнейшим развитием данной работы.
%\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
%\bibliographystyle{ugost2008ls}
\input{./Gorohov/bib}

